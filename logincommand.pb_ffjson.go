// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: logincommand.pb.go
// DO NOT EDIT!

package main

import (
	"bytes"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *AccountTokenVerifyLoginUserPmd_CS) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AccountTokenVerifyLoginUserPmd_CS) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Account != nil {
		if true {
			buf.WriteString(`"account":`)
			fflib.WriteJsonString(buf, string(*mj.Account))
			buf.WriteByte(',')
		}
	}
	if mj.Token != nil {
		if true {
			buf.WriteString(`"token":`)
			fflib.WriteJsonString(buf, string(*mj.Token))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.FormatBits2(buf, uint64(*mj.Version), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Mid != nil {
		if true {
			buf.WriteString(`"mid":`)
			fflib.WriteJsonString(buf, string(*mj.Mid))
			buf.WriteByte(',')
		}
	}
	if mj.Platid != nil {
		if true {
			buf.WriteString(`"platid":`)
			fflib.FormatBits2(buf, uint64(*mj.Platid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gameversion != nil {
		if true {
			buf.WriteString(`"gameversion":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameversion), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Compress != nil {
		if true {
			buf.WriteString(`"compress":`)
			fflib.WriteJsonString(buf, string(*mj.Compress))
			buf.WriteByte(',')
		}
	}
	if mj.Encrypt != nil {
		if true {
			buf.WriteString(`"encrypt":`)
			fflib.WriteJsonString(buf, string(*mj.Encrypt))
			buf.WriteByte(',')
		}
	}
	if mj.Encryptkey != nil {
		if true {
			buf.WriteString(`"encryptkey":`)
			fflib.WriteJsonString(buf, string(*mj.Encryptkey))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AccountTokenVerifyLoginUserPmd_CSbase = iota
	ffj_t_AccountTokenVerifyLoginUserPmd_CSno_such_key

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Account

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Token

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Version

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameid

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Mid

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Platid

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Zoneid

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameversion

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Compress

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encrypt

	ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encryptkey
)

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Account = []byte("account")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Token = []byte("token")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Version = []byte("version")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Gameid = []byte("gameid")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Mid = []byte("mid")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Platid = []byte("platid")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Zoneid = []byte("zoneid")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Gameversion = []byte("gameversion")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Compress = []byte("compress")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Encrypt = []byte("encrypt")

var ffj_key_AccountTokenVerifyLoginUserPmd_CS_Encryptkey = []byte("encryptkey")

func (uj *AccountTokenVerifyLoginUserPmd_CS) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AccountTokenVerifyLoginUserPmd_CS) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AccountTokenVerifyLoginUserPmd_CSbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CSno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Account, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Account
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Compress, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Compress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Encrypt, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encrypt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Encryptkey, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encryptkey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Gameid, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Gameversion, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameversion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Mid, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Mid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Platid, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Platid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Token, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Token
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Version, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Zoneid, kn) {
						currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Encryptkey, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encryptkey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Encrypt, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encrypt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Compress, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Compress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Gameversion, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameversion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Zoneid, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Platid, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Platid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Mid, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Mid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Gameid, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Version, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Token, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Token
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AccountTokenVerifyLoginUserPmd_CS_Account, kn) {
					currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CS_Account
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AccountTokenVerifyLoginUserPmd_CSno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Account:
					goto handle_Account

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Token:
					goto handle_Token

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Version:
					goto handle_Version

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameid:
					goto handle_Gameid

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Mid:
					goto handle_Mid

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Platid:
					goto handle_Platid

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Zoneid:
					goto handle_Zoneid

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Gameversion:
					goto handle_Gameversion

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Compress:
					goto handle_Compress

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encrypt:
					goto handle_Encrypt

				case ffj_t_AccountTokenVerifyLoginUserPmd_CS_Encryptkey:
					goto handle_Encryptkey

				case ffj_t_AccountTokenVerifyLoginUserPmd_CSno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Account:

	/* handler: uj.Account type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Account = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Account = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Token:

	/* handler: uj.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Token = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Token = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Version = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mid:

	/* handler: uj.Mid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Mid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Mid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platid:

	/* handler: uj.Platid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Platid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Platid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameversion:

	/* handler: uj.Gameversion type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameversion = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameversion = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Compress:

	/* handler: uj.Compress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Compress = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Compress = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encrypt:

	/* handler: uj.Encrypt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encrypt = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encrypt = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encryptkey:

	/* handler: uj.Encryptkey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encryptkey = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encryptkey = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *AccountTokenVerifyReturnLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *AccountTokenVerifyReturnLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Retcode != nil {
		if true {
			buf.WriteString(`"retcode":`)
			fflib.FormatBits2(buf, uint64(*mj.Retcode), 10, *mj.Retcode < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_AccountTokenVerifyReturnLoginUserPmd_Sbase = iota
	ffj_t_AccountTokenVerifyReturnLoginUserPmd_Sno_such_key

	ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Retcode

	ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Desc
)

var ffj_key_AccountTokenVerifyReturnLoginUserPmd_S_Retcode = []byte("retcode")

var ffj_key_AccountTokenVerifyReturnLoginUserPmd_S_Desc = []byte("desc")

func (uj *AccountTokenVerifyReturnLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *AccountTokenVerifyReturnLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_AccountTokenVerifyReturnLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_AccountTokenVerifyReturnLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_AccountTokenVerifyReturnLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_AccountTokenVerifyReturnLoginUserPmd_S_Retcode, kn) {
						currentKey = ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Retcode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_AccountTokenVerifyReturnLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_AccountTokenVerifyReturnLoginUserPmd_S_Retcode, kn) {
					currentKey = ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Retcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_AccountTokenVerifyReturnLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Retcode:
					goto handle_Retcode

				case ffj_t_AccountTokenVerifyReturnLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_AccountTokenVerifyReturnLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Retcode:

	/* handler: uj.Retcode type=Pmd.VerifyReturnReason kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Retcode = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Retcode == nil {
			uj.Retcode = new(VerifyReturnReason)
		}

		err = uj.Retcode.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *BehaviorClientVerifyLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *BehaviorClientVerifyLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Account != nil {
		if true {
			buf.WriteString(`"account":`)
			fflib.WriteJsonString(buf, string(*mj.Account))
			buf.WriteByte(',')
		}
	}
	if mj.Token != nil {
		if true {
			buf.WriteString(`"token":`)
			fflib.WriteJsonString(buf, string(*mj.Token))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.FormatBits2(buf, uint64(*mj.Version), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Mid != nil {
		if true {
			buf.WriteString(`"mid":`)
			fflib.WriteJsonString(buf, string(*mj.Mid))
			buf.WriteByte(',')
		}
	}
	if mj.Platid != nil {
		if true {
			buf.WriteString(`"platid":`)
			fflib.FormatBits2(buf, uint64(*mj.Platid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gameversion != nil {
		if true {
			buf.WriteString(`"gameversion":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameversion), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Compress != nil {
		if true {
			buf.WriteString(`"compress":`)
			fflib.WriteJsonString(buf, string(*mj.Compress))
			buf.WriteByte(',')
		}
	}
	if mj.Encrypt != nil {
		if true {
			buf.WriteString(`"encrypt":`)
			fflib.WriteJsonString(buf, string(*mj.Encrypt))
			buf.WriteByte(',')
		}
	}
	if mj.Encryptkey != nil {
		if true {
			buf.WriteString(`"encryptkey":`)
			fflib.WriteJsonString(buf, string(*mj.Encryptkey))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_BehaviorClientVerifyLoginUserPmd_Cbase = iota
	ffj_t_BehaviorClientVerifyLoginUserPmd_Cno_such_key

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Account

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Token

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Version

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameid

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Mid

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Platid

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Zoneid

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameversion

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Compress

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encrypt

	ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encryptkey
)

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Account = []byte("account")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Token = []byte("token")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Version = []byte("version")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Gameid = []byte("gameid")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Mid = []byte("mid")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Platid = []byte("platid")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Zoneid = []byte("zoneid")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Gameversion = []byte("gameversion")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Compress = []byte("compress")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Encrypt = []byte("encrypt")

var ffj_key_BehaviorClientVerifyLoginUserPmd_C_Encryptkey = []byte("encryptkey")

func (uj *BehaviorClientVerifyLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *BehaviorClientVerifyLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_BehaviorClientVerifyLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Account, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Account
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Compress, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Compress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Encrypt, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encrypt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Encryptkey, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encryptkey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Gameversion, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameversion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Mid, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Mid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Platid, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Platid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Token, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Token
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Version, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Zoneid, kn) {
						currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Encryptkey, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encryptkey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Encrypt, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encrypt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Compress, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Compress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Gameversion, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameversion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Zoneid, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Platid, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Platid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Mid, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Mid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Version, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Token, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Token
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_BehaviorClientVerifyLoginUserPmd_C_Account, kn) {
					currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_C_Account
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_BehaviorClientVerifyLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Account:
					goto handle_Account

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Token:
					goto handle_Token

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Version:
					goto handle_Version

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Mid:
					goto handle_Mid

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Platid:
					goto handle_Platid

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Zoneid:
					goto handle_Zoneid

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Gameversion:
					goto handle_Gameversion

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Compress:
					goto handle_Compress

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encrypt:
					goto handle_Encrypt

				case ffj_t_BehaviorClientVerifyLoginUserPmd_C_Encryptkey:
					goto handle_Encryptkey

				case ffj_t_BehaviorClientVerifyLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Account:

	/* handler: uj.Account type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Account = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Account = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Token:

	/* handler: uj.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Token = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Token = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Version = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mid:

	/* handler: uj.Mid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Mid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Mid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platid:

	/* handler: uj.Platid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Platid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Platid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameversion:

	/* handler: uj.Gameversion type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameversion = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameversion = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Compress:

	/* handler: uj.Compress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Compress = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Compress = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encrypt:

	/* handler: uj.Encrypt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encrypt = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encrypt = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encryptkey:

	/* handler: uj.Encryptkey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encryptkey = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encryptkey = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *CheckVersionLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CheckVersionLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.DefaultCharid != nil {
		if true {
			buf.WriteString(`"default_charid":`)
			fflib.FormatBits2(buf, uint64(*mj.DefaultCharid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.FormatBits2(buf, uint64(*mj.Version), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CheckVersionLoginUserPmd_Cbase = iota
	ffj_t_CheckVersionLoginUserPmd_Cno_such_key

	ffj_t_CheckVersionLoginUserPmd_C_DefaultCharid

	ffj_t_CheckVersionLoginUserPmd_C_Version
)

var ffj_key_CheckVersionLoginUserPmd_C_DefaultCharid = []byte("default_charid")

var ffj_key_CheckVersionLoginUserPmd_C_Version = []byte("version")

func (uj *CheckVersionLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CheckVersionLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CheckVersionLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CheckVersionLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_CheckVersionLoginUserPmd_C_DefaultCharid, kn) {
						currentKey = ffj_t_CheckVersionLoginUserPmd_C_DefaultCharid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_CheckVersionLoginUserPmd_C_Version, kn) {
						currentKey = ffj_t_CheckVersionLoginUserPmd_C_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_CheckVersionLoginUserPmd_C_Version, kn) {
					currentKey = ffj_t_CheckVersionLoginUserPmd_C_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_CheckVersionLoginUserPmd_C_DefaultCharid, kn) {
					currentKey = ffj_t_CheckVersionLoginUserPmd_C_DefaultCharid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CheckVersionLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CheckVersionLoginUserPmd_C_DefaultCharid:
					goto handle_DefaultCharid

				case ffj_t_CheckVersionLoginUserPmd_C_Version:
					goto handle_Version

				case ffj_t_CheckVersionLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_DefaultCharid:

	/* handler: uj.DefaultCharid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.DefaultCharid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.DefaultCharid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Version = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ClientLogUrlLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ClientLogUrlLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Loglevel != nil {
		if true {
			buf.WriteString(`"loglevel":`)
			fflib.WriteJsonString(buf, string(*mj.Loglevel))
			buf.WriteByte(',')
		}
	}
	if mj.Logurl != nil {
		if true {
			buf.WriteString(`"logurl":`)
			fflib.WriteJsonString(buf, string(*mj.Logurl))
			buf.WriteByte(',')
		}
	}
	if mj.Distinct != nil {
		if true {
			if *mj.Distinct {
				buf.WriteString(`"distinct":true`)
			} else {
				buf.WriteString(`"distinct":false`)
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ClientLogUrlLoginUserPmd_Sbase = iota
	ffj_t_ClientLogUrlLoginUserPmd_Sno_such_key

	ffj_t_ClientLogUrlLoginUserPmd_S_Loglevel

	ffj_t_ClientLogUrlLoginUserPmd_S_Logurl

	ffj_t_ClientLogUrlLoginUserPmd_S_Distinct
)

var ffj_key_ClientLogUrlLoginUserPmd_S_Loglevel = []byte("loglevel")

var ffj_key_ClientLogUrlLoginUserPmd_S_Logurl = []byte("logurl")

var ffj_key_ClientLogUrlLoginUserPmd_S_Distinct = []byte("distinct")

func (uj *ClientLogUrlLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ClientLogUrlLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ClientLogUrlLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ClientLogUrlLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_ClientLogUrlLoginUserPmd_S_Distinct, kn) {
						currentKey = ffj_t_ClientLogUrlLoginUserPmd_S_Distinct
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_ClientLogUrlLoginUserPmd_S_Loglevel, kn) {
						currentKey = ffj_t_ClientLogUrlLoginUserPmd_S_Loglevel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ClientLogUrlLoginUserPmd_S_Logurl, kn) {
						currentKey = ffj_t_ClientLogUrlLoginUserPmd_S_Logurl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ClientLogUrlLoginUserPmd_S_Distinct, kn) {
					currentKey = ffj_t_ClientLogUrlLoginUserPmd_S_Distinct
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ClientLogUrlLoginUserPmd_S_Logurl, kn) {
					currentKey = ffj_t_ClientLogUrlLoginUserPmd_S_Logurl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ClientLogUrlLoginUserPmd_S_Loglevel, kn) {
					currentKey = ffj_t_ClientLogUrlLoginUserPmd_S_Loglevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ClientLogUrlLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ClientLogUrlLoginUserPmd_S_Loglevel:
					goto handle_Loglevel

				case ffj_t_ClientLogUrlLoginUserPmd_S_Logurl:
					goto handle_Logurl

				case ffj_t_ClientLogUrlLoginUserPmd_S_Distinct:
					goto handle_Distinct

				case ffj_t_ClientLogUrlLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Loglevel:

	/* handler: uj.Loglevel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Loglevel = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Loglevel = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Logurl:

	/* handler: uj.Logurl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Logurl = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Logurl = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Distinct:

	/* handler: uj.Distinct type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Distinct = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Distinct = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EmailRegistRequestCreateAccountLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EmailRegistRequestCreateAccountLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Email != nil {
		if true {
			buf.WriteString(`"email":`)
			fflib.WriteJsonString(buf, string(*mj.Email))
			buf.WriteByte(',')
		}
	}
	if mj.Password != nil {
		if true {
			buf.WriteString(`"password":`)
			fflib.WriteJsonString(buf, string(*mj.Password))
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Isbind != nil {
		if true {
			if *mj.Isbind {
				buf.WriteString(`"isbind":true`)
			} else {
				buf.WriteString(`"isbind":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Uid != nil {
		if true {
			buf.WriteString(`"uid":`)
			fflib.FormatBits2(buf, uint64(*mj.Uid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_Cbase = iota
	ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_Cno_such_key

	ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Email

	ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Password

	ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Gameid

	ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Isbind

	ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Uid
)

var ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Email = []byte("email")

var ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Password = []byte("password")

var ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Gameid = []byte("gameid")

var ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Isbind = []byte("isbind")

var ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Uid = []byte("uid")

func (uj *EmailRegistRequestCreateAccountLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EmailRegistRequestCreateAccountLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Email, kn) {
						currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Email
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Isbind, kn) {
						currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Isbind
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Password, kn) {
						currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Password
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Uid, kn) {
						currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Uid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Uid, kn) {
					currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Uid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Isbind, kn) {
					currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Isbind
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Password, kn) {
					currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRegistRequestCreateAccountLoginUserPmd_C_Email, kn) {
					currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Email:
					goto handle_Email

				case ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Password:
					goto handle_Password

				case ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Isbind:
					goto handle_Isbind

				case ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_C_Uid:
					goto handle_Uid

				case ffj_t_EmailRegistRequestCreateAccountLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Email = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Email = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Password = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Password = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Isbind:

	/* handler: uj.Isbind type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Isbind = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Isbind = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Uid:

	/* handler: uj.Uid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Uid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Uid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *EmailRegistReturnCreateAccountLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *EmailRegistReturnCreateAccountLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Retcode != nil {
		if true {
			buf.WriteString(`"retcode":`)
			fflib.FormatBits2(buf, uint64(*mj.Retcode), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	if mj.Uid != nil {
		if true {
			buf.WriteString(`"uid":`)
			fflib.FormatBits2(buf, uint64(*mj.Uid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_Sbase = iota
	ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_Sno_such_key

	ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Retcode

	ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Desc

	ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Uid
)

var ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Retcode = []byte("retcode")

var ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Desc = []byte("desc")

var ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Uid = []byte("uid")

func (uj *EmailRegistReturnCreateAccountLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *EmailRegistReturnCreateAccountLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Retcode, kn) {
						currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Retcode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Uid, kn) {
						currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Uid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Uid, kn) {
					currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Uid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_EmailRegistReturnCreateAccountLoginUserPmd_S_Retcode, kn) {
					currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Retcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Retcode:
					goto handle_Retcode

				case ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_S_Uid:
					goto handle_Uid

				case ffj_t_EmailRegistReturnCreateAccountLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Retcode:

	/* handler: uj.Retcode type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Retcode = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Retcode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Uid:

	/* handler: uj.Uid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Uid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Uid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *GameServerShutDownLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *GameServerShutDownLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_GameServerShutDownLoginUserPmd_Sbase = iota
	ffj_t_GameServerShutDownLoginUserPmd_Sno_such_key

	ffj_t_GameServerShutDownLoginUserPmd_S_Desc
)

var ffj_key_GameServerShutDownLoginUserPmd_S_Desc = []byte("desc")

func (uj *GameServerShutDownLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *GameServerShutDownLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_GameServerShutDownLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_GameServerShutDownLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_GameServerShutDownLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_GameServerShutDownLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_GameServerShutDownLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_GameServerShutDownLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_GameServerShutDownLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_GameServerShutDownLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_GameServerShutDownLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *Login) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Login) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffj_t_Loginbase = iota
	ffj_t_Loginno_such_key
)

func (uj *Login) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Login) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Loginbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Loginno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffj_t_Loginno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Loginno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MessageBoxLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MessageBoxLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Btnleft != nil {
		if true {
			buf.WriteString(`"btnleft":`)
			fflib.WriteJsonString(buf, string(*mj.Btnleft))
			buf.WriteByte(',')
		}
	}
	if mj.Btnmiddle != nil {
		if true {
			buf.WriteString(`"btnmiddle":`)
			fflib.WriteJsonString(buf, string(*mj.Btnmiddle))
			buf.WriteByte(',')
		}
	}
	if mj.Btnright != nil {
		if true {
			buf.WriteString(`"btnright":`)
			fflib.WriteJsonString(buf, string(*mj.Btnright))
			buf.WriteByte(',')
		}
	}
	if mj.Info != nil {
		if true {
			buf.WriteString(`"info":`)
			fflib.WriteJsonString(buf, string(*mj.Info))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MessageBoxLoginUserPmd_Sbase = iota
	ffj_t_MessageBoxLoginUserPmd_Sno_such_key

	ffj_t_MessageBoxLoginUserPmd_S_Btnleft

	ffj_t_MessageBoxLoginUserPmd_S_Btnmiddle

	ffj_t_MessageBoxLoginUserPmd_S_Btnright

	ffj_t_MessageBoxLoginUserPmd_S_Info
)

var ffj_key_MessageBoxLoginUserPmd_S_Btnleft = []byte("btnleft")

var ffj_key_MessageBoxLoginUserPmd_S_Btnmiddle = []byte("btnmiddle")

var ffj_key_MessageBoxLoginUserPmd_S_Btnright = []byte("btnright")

var ffj_key_MessageBoxLoginUserPmd_S_Info = []byte("info")

func (uj *MessageBoxLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MessageBoxLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MessageBoxLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MessageBoxLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_MessageBoxLoginUserPmd_S_Btnleft, kn) {
						currentKey = ffj_t_MessageBoxLoginUserPmd_S_Btnleft
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageBoxLoginUserPmd_S_Btnmiddle, kn) {
						currentKey = ffj_t_MessageBoxLoginUserPmd_S_Btnmiddle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_MessageBoxLoginUserPmd_S_Btnright, kn) {
						currentKey = ffj_t_MessageBoxLoginUserPmd_S_Btnright
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_MessageBoxLoginUserPmd_S_Info, kn) {
						currentKey = ffj_t_MessageBoxLoginUserPmd_S_Info
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageBoxLoginUserPmd_S_Info, kn) {
					currentKey = ffj_t_MessageBoxLoginUserPmd_S_Info
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageBoxLoginUserPmd_S_Btnright, kn) {
					currentKey = ffj_t_MessageBoxLoginUserPmd_S_Btnright
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageBoxLoginUserPmd_S_Btnmiddle, kn) {
					currentKey = ffj_t_MessageBoxLoginUserPmd_S_Btnmiddle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageBoxLoginUserPmd_S_Btnleft, kn) {
					currentKey = ffj_t_MessageBoxLoginUserPmd_S_Btnleft
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MessageBoxLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MessageBoxLoginUserPmd_S_Btnleft:
					goto handle_Btnleft

				case ffj_t_MessageBoxLoginUserPmd_S_Btnmiddle:
					goto handle_Btnmiddle

				case ffj_t_MessageBoxLoginUserPmd_S_Btnright:
					goto handle_Btnright

				case ffj_t_MessageBoxLoginUserPmd_S_Info:
					goto handle_Info

				case ffj_t_MessageBoxLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Btnleft:

	/* handler: uj.Btnleft type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Btnleft = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Btnleft = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Btnmiddle:

	/* handler: uj.Btnmiddle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Btnmiddle = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Btnmiddle = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Btnright:

	/* handler: uj.Btnright type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Btnright = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Btnright = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Info:

	/* handler: uj.Info type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Info = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Info = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MobileRegistRequestCreateAccountLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MobileRegistRequestCreateAccountLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Mobilenum != nil {
		if true {
			buf.WriteString(`"mobilenum":`)
			fflib.WriteJsonString(buf, string(*mj.Mobilenum))
			buf.WriteByte(',')
		}
	}
	if mj.Randcode != nil {
		if true {
			buf.WriteString(`"randcode":`)
			fflib.WriteJsonString(buf, string(*mj.Randcode))
			buf.WriteByte(',')
		}
	}
	if mj.Password != nil {
		if true {
			buf.WriteString(`"password":`)
			fflib.WriteJsonString(buf, string(*mj.Password))
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_Cbase = iota
	ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_Cno_such_key

	ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Mobilenum

	ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Randcode

	ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Password

	ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Gameid
)

var ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Mobilenum = []byte("mobilenum")

var ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Randcode = []byte("randcode")

var ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Password = []byte("password")

var ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Gameid = []byte("gameid")

func (uj *MobileRegistRequestCreateAccountLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MobileRegistRequestCreateAccountLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Mobilenum, kn) {
						currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Mobilenum
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Password, kn) {
						currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Password
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Randcode, kn) {
						currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Randcode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Password, kn) {
					currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Randcode, kn) {
					currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Randcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistRequestCreateAccountLoginUserPmd_C_Mobilenum, kn) {
					currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Mobilenum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Mobilenum:
					goto handle_Mobilenum

				case ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Randcode:
					goto handle_Randcode

				case ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Password:
					goto handle_Password

				case ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_MobileRegistRequestCreateAccountLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Mobilenum:

	/* handler: uj.Mobilenum type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Mobilenum = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Mobilenum = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Randcode:

	/* handler: uj.Randcode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Randcode = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Randcode = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Password = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Password = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MobileRegistRequestRandCodeLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MobileRegistRequestRandCodeLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Mobilenum != nil {
		if true {
			buf.WriteString(`"mobilenum":`)
			fflib.WriteJsonString(buf, string(*mj.Mobilenum))
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MobileRegistRequestRandCodeLoginUserPmd_Cbase = iota
	ffj_t_MobileRegistRequestRandCodeLoginUserPmd_Cno_such_key

	ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Mobilenum

	ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Gameid
)

var ffj_key_MobileRegistRequestRandCodeLoginUserPmd_C_Mobilenum = []byte("mobilenum")

var ffj_key_MobileRegistRequestRandCodeLoginUserPmd_C_Gameid = []byte("gameid")

func (uj *MobileRegistRequestRandCodeLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MobileRegistRequestRandCodeLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MobileRegistRequestRandCodeLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MobileRegistRequestRandCodeLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_MobileRegistRequestRandCodeLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_MobileRegistRequestRandCodeLoginUserPmd_C_Mobilenum, kn) {
						currentKey = ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Mobilenum
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistRequestRandCodeLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistRequestRandCodeLoginUserPmd_C_Mobilenum, kn) {
					currentKey = ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Mobilenum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MobileRegistRequestRandCodeLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Mobilenum:
					goto handle_Mobilenum

				case ffj_t_MobileRegistRequestRandCodeLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_MobileRegistRequestRandCodeLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Mobilenum:

	/* handler: uj.Mobilenum type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Mobilenum = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Mobilenum = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MobileRegistReturnCreateAccountFailLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MobileRegistReturnCreateAccountFailLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Retcode != nil {
		if true {
			buf.WriteString(`"retcode":`)
			fflib.FormatBits2(buf, uint64(*mj.Retcode), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_Sbase = iota
	ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_Sno_such_key

	ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Retcode

	ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Desc
)

var ffj_key_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Retcode = []byte("retcode")

var ffj_key_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Desc = []byte("desc")

func (uj *MobileRegistReturnCreateAccountFailLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MobileRegistReturnCreateAccountFailLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Retcode, kn) {
						currentKey = ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Retcode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Retcode, kn) {
					currentKey = ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Retcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Retcode:
					goto handle_Retcode

				case ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_MobileRegistReturnCreateAccountFailLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Retcode:

	/* handler: uj.Retcode type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Retcode = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Retcode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *MobileRegistReturnRandCodeLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MobileRegistReturnRandCodeLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Retcode != nil {
		if true {
			buf.WriteString(`"retcode":`)
			fflib.FormatBits2(buf, uint64(*mj.Retcode), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	if mj.Timeout != nil {
		if true {
			buf.WriteString(`"timeout":`)
			fflib.FormatBits2(buf, uint64(*mj.Timeout), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MobileRegistReturnRandCodeLoginUserPmd_Sbase = iota
	ffj_t_MobileRegistReturnRandCodeLoginUserPmd_Sno_such_key

	ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Retcode

	ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Desc

	ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Timeout
)

var ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Retcode = []byte("retcode")

var ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Desc = []byte("desc")

var ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Timeout = []byte("timeout")

func (uj *MobileRegistReturnRandCodeLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MobileRegistReturnRandCodeLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MobileRegistReturnRandCodeLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Retcode, kn) {
						currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Retcode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Timeout, kn) {
						currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Timeout
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Timeout, kn) {
					currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Timeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MobileRegistReturnRandCodeLoginUserPmd_S_Retcode, kn) {
					currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Retcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MobileRegistReturnRandCodeLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Retcode:
					goto handle_Retcode

				case ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_MobileRegistReturnRandCodeLoginUserPmd_S_Timeout:
					goto handle_Timeout

				case ffj_t_MobileRegistReturnRandCodeLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Retcode:

	/* handler: uj.Retcode type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Retcode = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Retcode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timeout:

	/* handler: uj.Timeout type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Timeout = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Timeout = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PlatInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PlatInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Account != nil {
		if true {
			buf.WriteString(`"account":`)
			fflib.WriteJsonString(buf, string(*mj.Account))
			buf.WriteByte(',')
		}
	}
	if mj.Platid != nil {
		if true {
			buf.WriteString(`"platid":`)
			fflib.FormatBits2(buf, uint64(*mj.Platid), 10, *mj.Platid < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Email != nil {
		if true {
			buf.WriteString(`"email":`)
			fflib.WriteJsonString(buf, string(*mj.Email))
			buf.WriteByte(',')
		}
	}
	if mj.Gender != nil {
		if true {
			buf.WriteString(`"gender":`)
			fflib.WriteJsonString(buf, string(*mj.Gender))
			buf.WriteByte(',')
		}
	}
	if mj.Nickname != nil {
		if true {
			buf.WriteString(`"nickname":`)
			fflib.WriteJsonString(buf, string(*mj.Nickname))
			buf.WriteByte(',')
		}
	}
	if mj.Timestamp != nil {
		if true {
			buf.WriteString(`"timestamp":`)
			fflib.WriteJsonString(buf, string(*mj.Timestamp))
			buf.WriteByte(',')
		}
	}
	if mj.Sign != nil {
		if true {
			buf.WriteString(`"sign":`)
			fflib.WriteJsonString(buf, string(*mj.Sign))
			buf.WriteByte(',')
		}
	}
	if mj.Faceurl != nil {
		if true {
			buf.WriteString(`"faceurl":`)
			fflib.WriteJsonString(buf, string(*mj.Faceurl))
			buf.WriteByte(',')
		}
	}
	if mj.Extdata != nil {
		if true {
			buf.WriteString(`"extdata":`)
			fflib.WriteJsonString(buf, string(*mj.Extdata))
			buf.WriteByte(',')
		}
	}
	if mj.Uid != nil {
		if true {
			buf.WriteString(`"uid":`)
			fflib.WriteJsonString(buf, string(*mj.Uid))
			buf.WriteByte(',')
		}
	}
	if mj.Imei != nil {
		if true {
			buf.WriteString(`"imei":`)
			fflib.FormatBits2(buf, uint64(*mj.Imei), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Osname != nil {
		if true {
			buf.WriteString(`"osname":`)
			fflib.WriteJsonString(buf, string(*mj.Osname))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PlatInfobase = iota
	ffj_t_PlatInfono_such_key

	ffj_t_PlatInfo_Account

	ffj_t_PlatInfo_Platid

	ffj_t_PlatInfo_Email

	ffj_t_PlatInfo_Gender

	ffj_t_PlatInfo_Nickname

	ffj_t_PlatInfo_Timestamp

	ffj_t_PlatInfo_Sign

	ffj_t_PlatInfo_Faceurl

	ffj_t_PlatInfo_Extdata

	ffj_t_PlatInfo_Uid

	ffj_t_PlatInfo_Imei

	ffj_t_PlatInfo_Osname
)

var ffj_key_PlatInfo_Account = []byte("account")

var ffj_key_PlatInfo_Platid = []byte("platid")

var ffj_key_PlatInfo_Email = []byte("email")

var ffj_key_PlatInfo_Gender = []byte("gender")

var ffj_key_PlatInfo_Nickname = []byte("nickname")

var ffj_key_PlatInfo_Timestamp = []byte("timestamp")

var ffj_key_PlatInfo_Sign = []byte("sign")

var ffj_key_PlatInfo_Faceurl = []byte("faceurl")

var ffj_key_PlatInfo_Extdata = []byte("extdata")

var ffj_key_PlatInfo_Uid = []byte("uid")

var ffj_key_PlatInfo_Imei = []byte("imei")

var ffj_key_PlatInfo_Osname = []byte("osname")

func (uj *PlatInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PlatInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PlatInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PlatInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PlatInfo_Account, kn) {
						currentKey = ffj_t_PlatInfo_Account
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_PlatInfo_Email, kn) {
						currentKey = ffj_t_PlatInfo_Email
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PlatInfo_Extdata, kn) {
						currentKey = ffj_t_PlatInfo_Extdata
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_PlatInfo_Faceurl, kn) {
						currentKey = ffj_t_PlatInfo_Faceurl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_PlatInfo_Gender, kn) {
						currentKey = ffj_t_PlatInfo_Gender
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_PlatInfo_Imei, kn) {
						currentKey = ffj_t_PlatInfo_Imei
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_PlatInfo_Nickname, kn) {
						currentKey = ffj_t_PlatInfo_Nickname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_PlatInfo_Osname, kn) {
						currentKey = ffj_t_PlatInfo_Osname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_PlatInfo_Platid, kn) {
						currentKey = ffj_t_PlatInfo_Platid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_PlatInfo_Sign, kn) {
						currentKey = ffj_t_PlatInfo_Sign
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PlatInfo_Timestamp, kn) {
						currentKey = ffj_t_PlatInfo_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_PlatInfo_Uid, kn) {
						currentKey = ffj_t_PlatInfo_Uid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PlatInfo_Osname, kn) {
					currentKey = ffj_t_PlatInfo_Osname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Imei, kn) {
					currentKey = ffj_t_PlatInfo_Imei
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Uid, kn) {
					currentKey = ffj_t_PlatInfo_Uid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Extdata, kn) {
					currentKey = ffj_t_PlatInfo_Extdata
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Faceurl, kn) {
					currentKey = ffj_t_PlatInfo_Faceurl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PlatInfo_Sign, kn) {
					currentKey = ffj_t_PlatInfo_Sign
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PlatInfo_Timestamp, kn) {
					currentKey = ffj_t_PlatInfo_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PlatInfo_Nickname, kn) {
					currentKey = ffj_t_PlatInfo_Nickname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Gender, kn) {
					currentKey = ffj_t_PlatInfo_Gender
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Email, kn) {
					currentKey = ffj_t_PlatInfo_Email
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Platid, kn) {
					currentKey = ffj_t_PlatInfo_Platid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PlatInfo_Account, kn) {
					currentKey = ffj_t_PlatInfo_Account
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PlatInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PlatInfo_Account:
					goto handle_Account

				case ffj_t_PlatInfo_Platid:
					goto handle_Platid

				case ffj_t_PlatInfo_Email:
					goto handle_Email

				case ffj_t_PlatInfo_Gender:
					goto handle_Gender

				case ffj_t_PlatInfo_Nickname:
					goto handle_Nickname

				case ffj_t_PlatInfo_Timestamp:
					goto handle_Timestamp

				case ffj_t_PlatInfo_Sign:
					goto handle_Sign

				case ffj_t_PlatInfo_Faceurl:
					goto handle_Faceurl

				case ffj_t_PlatInfo_Extdata:
					goto handle_Extdata

				case ffj_t_PlatInfo_Uid:
					goto handle_Uid

				case ffj_t_PlatInfo_Imei:
					goto handle_Imei

				case ffj_t_PlatInfo_Osname:
					goto handle_Osname

				case ffj_t_PlatInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Account:

	/* handler: uj.Account type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Account = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Account = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platid:

	/* handler: uj.Platid type=Pmd.PlatType kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Platid = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Platid == nil {
			uj.Platid = new(PlatType)
		}

		err = uj.Platid.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Email:

	/* handler: uj.Email type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Email = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Email = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gender:

	/* handler: uj.Gender type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Gender = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Gender = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nickname:

	/* handler: uj.Nickname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Nickname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Nickname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: uj.Timestamp type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Timestamp = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Timestamp = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sign:

	/* handler: uj.Sign type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Sign = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Sign = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Faceurl:

	/* handler: uj.Faceurl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Faceurl = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Faceurl = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extdata:

	/* handler: uj.Extdata type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Extdata = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Extdata = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Uid:

	/* handler: uj.Uid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Uid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Uid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Imei:

	/* handler: uj.Imei type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Imei = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Imei = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Osname:

	/* handler: uj.Osname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Osname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Osname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *PushAccountVerifyLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PushAccountVerifyLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Accid != nil {
		if true {
			buf.WriteString(`"accid":`)
			fflib.FormatBits2(buf, uint64(*mj.Accid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Account != nil {
		if true {
			buf.WriteString(`"account":`)
			fflib.WriteJsonString(buf, string(*mj.Account))
			buf.WriteByte(',')
		}
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Token != nil {
		if true {
			buf.WriteString(`"token":`)
			fflib.WriteJsonString(buf, string(*mj.Token))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.FormatBits2(buf, uint64(*mj.Version), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Mid != nil {
		if true {
			buf.WriteString(`"mid":`)
			fflib.WriteJsonString(buf, string(*mj.Mid))
			buf.WriteByte(',')
		}
	}
	if mj.Gameversion != nil {
		if true {
			buf.WriteString(`"gameversion":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameversion), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Compress != nil {
		if true {
			buf.WriteString(`"compress":`)
			fflib.WriteJsonString(buf, string(*mj.Compress))
			buf.WriteByte(',')
		}
	}
	if mj.Encrypt != nil {
		if true {
			buf.WriteString(`"encrypt":`)
			fflib.WriteJsonString(buf, string(*mj.Encrypt))
			buf.WriteByte(',')
		}
	}
	if mj.Encryptkey != nil {
		if true {
			buf.WriteString(`"encryptkey":`)
			fflib.WriteJsonString(buf, string(*mj.Encryptkey))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PushAccountVerifyLoginUserPmd_Cbase = iota
	ffj_t_PushAccountVerifyLoginUserPmd_Cno_such_key

	ffj_t_PushAccountVerifyLoginUserPmd_C_Accid

	ffj_t_PushAccountVerifyLoginUserPmd_C_Account

	ffj_t_PushAccountVerifyLoginUserPmd_C_Zoneid

	ffj_t_PushAccountVerifyLoginUserPmd_C_Token

	ffj_t_PushAccountVerifyLoginUserPmd_C_Version

	ffj_t_PushAccountVerifyLoginUserPmd_C_Mid

	ffj_t_PushAccountVerifyLoginUserPmd_C_Gameversion

	ffj_t_PushAccountVerifyLoginUserPmd_C_Compress

	ffj_t_PushAccountVerifyLoginUserPmd_C_Encrypt

	ffj_t_PushAccountVerifyLoginUserPmd_C_Encryptkey
)

var ffj_key_PushAccountVerifyLoginUserPmd_C_Accid = []byte("accid")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Account = []byte("account")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Zoneid = []byte("zoneid")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Token = []byte("token")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Version = []byte("version")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Mid = []byte("mid")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Gameversion = []byte("gameversion")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Compress = []byte("compress")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Encrypt = []byte("encrypt")

var ffj_key_PushAccountVerifyLoginUserPmd_C_Encryptkey = []byte("encryptkey")

func (uj *PushAccountVerifyLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PushAccountVerifyLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PushAccountVerifyLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PushAccountVerifyLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Accid, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Accid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Account, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Account
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Compress, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Compress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Encrypt, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Encrypt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Encryptkey, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Encryptkey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Gameversion, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Gameversion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Mid, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Mid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Token, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Token
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Version, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_PushAccountVerifyLoginUserPmd_C_Zoneid, kn) {
						currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PushAccountVerifyLoginUserPmd_C_Encryptkey, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Encryptkey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PushAccountVerifyLoginUserPmd_C_Encrypt, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Encrypt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PushAccountVerifyLoginUserPmd_C_Compress, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Compress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PushAccountVerifyLoginUserPmd_C_Gameversion, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Gameversion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PushAccountVerifyLoginUserPmd_C_Mid, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Mid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PushAccountVerifyLoginUserPmd_C_Version, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_PushAccountVerifyLoginUserPmd_C_Token, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Token
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PushAccountVerifyLoginUserPmd_C_Zoneid, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PushAccountVerifyLoginUserPmd_C_Account, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Account
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PushAccountVerifyLoginUserPmd_C_Accid, kn) {
					currentKey = ffj_t_PushAccountVerifyLoginUserPmd_C_Accid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PushAccountVerifyLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Accid:
					goto handle_Accid

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Account:
					goto handle_Account

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Zoneid:
					goto handle_Zoneid

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Token:
					goto handle_Token

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Version:
					goto handle_Version

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Mid:
					goto handle_Mid

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Gameversion:
					goto handle_Gameversion

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Compress:
					goto handle_Compress

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Encrypt:
					goto handle_Encrypt

				case ffj_t_PushAccountVerifyLoginUserPmd_C_Encryptkey:
					goto handle_Encryptkey

				case ffj_t_PushAccountVerifyLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Accid:

	/* handler: uj.Accid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Accid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Accid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Account:

	/* handler: uj.Account type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Account = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Account = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Token:

	/* handler: uj.Token type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Token = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Token = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Version = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mid:

	/* handler: uj.Mid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Mid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Mid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameversion:

	/* handler: uj.Gameversion type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameversion = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameversion = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Compress:

	/* handler: uj.Compress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Compress = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Compress = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encrypt:

	/* handler: uj.Encrypt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encrypt = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encrypt = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encryptkey:

	/* handler: uj.Encryptkey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encryptkey = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encryptkey = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReconnectErrorLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReconnectErrorLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReconnectErrorLoginUserPmd_Sbase = iota
	ffj_t_ReconnectErrorLoginUserPmd_Sno_such_key

	ffj_t_ReconnectErrorLoginUserPmd_S_Desc
)

var ffj_key_ReconnectErrorLoginUserPmd_S_Desc = []byte("desc")

func (uj *ReconnectErrorLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReconnectErrorLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReconnectErrorLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReconnectErrorLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_ReconnectErrorLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_ReconnectErrorLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReconnectErrorLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_ReconnectErrorLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReconnectErrorLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReconnectErrorLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_ReconnectErrorLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReconnectKickoutLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReconnectKickoutLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReconnectKickoutLoginUserPmd_Sbase = iota
	ffj_t_ReconnectKickoutLoginUserPmd_Sno_such_key

	ffj_t_ReconnectKickoutLoginUserPmd_S_Desc
)

var ffj_key_ReconnectKickoutLoginUserPmd_S_Desc = []byte("desc")

func (uj *ReconnectKickoutLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReconnectKickoutLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReconnectKickoutLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReconnectKickoutLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_ReconnectKickoutLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_ReconnectKickoutLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReconnectKickoutLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_ReconnectKickoutLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReconnectKickoutLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReconnectKickoutLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_ReconnectKickoutLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RequestAccountRegisterLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RequestAccountRegisterLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Account != nil {
		if true {
			buf.WriteString(`"account":`)
			fflib.WriteJsonString(buf, string(*mj.Account))
			buf.WriteByte(',')
		}
	}
	if mj.Password != nil {
		if true {
			buf.WriteString(`"password":`)
			fflib.WriteJsonString(buf, string(*mj.Password))
			buf.WriteByte(',')
		}
	}
	if mj.Code != nil {
		if true {
			buf.WriteString(`"code":`)
			fflib.WriteJsonString(buf, string(*mj.Code))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RequestAccountRegisterLoginUserPmd_Cbase = iota
	ffj_t_RequestAccountRegisterLoginUserPmd_Cno_such_key

	ffj_t_RequestAccountRegisterLoginUserPmd_C_Account

	ffj_t_RequestAccountRegisterLoginUserPmd_C_Password

	ffj_t_RequestAccountRegisterLoginUserPmd_C_Code
)

var ffj_key_RequestAccountRegisterLoginUserPmd_C_Account = []byte("account")

var ffj_key_RequestAccountRegisterLoginUserPmd_C_Password = []byte("password")

var ffj_key_RequestAccountRegisterLoginUserPmd_C_Code = []byte("code")

func (uj *RequestAccountRegisterLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RequestAccountRegisterLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RequestAccountRegisterLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_RequestAccountRegisterLoginUserPmd_C_Account, kn) {
						currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_C_Account
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_RequestAccountRegisterLoginUserPmd_C_Code, kn) {
						currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_C_Code
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_RequestAccountRegisterLoginUserPmd_C_Password, kn) {
						currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_C_Password
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_RequestAccountRegisterLoginUserPmd_C_Code, kn) {
					currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_C_Code
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_RequestAccountRegisterLoginUserPmd_C_Password, kn) {
					currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_C_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_RequestAccountRegisterLoginUserPmd_C_Account, kn) {
					currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_C_Account
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RequestAccountRegisterLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RequestAccountRegisterLoginUserPmd_C_Account:
					goto handle_Account

				case ffj_t_RequestAccountRegisterLoginUserPmd_C_Password:
					goto handle_Password

				case ffj_t_RequestAccountRegisterLoginUserPmd_C_Code:
					goto handle_Code

				case ffj_t_RequestAccountRegisterLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Account:

	/* handler: uj.Account type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Account = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Account = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Password = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Password = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Code:

	/* handler: uj.Code type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Code = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Code = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RequestClientIPLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RequestClientIPLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffj_t_RequestClientIPLoginUserPmd_Cbase = iota
	ffj_t_RequestClientIPLoginUserPmd_Cno_such_key
)

func (uj *RequestClientIPLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RequestClientIPLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RequestClientIPLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RequestClientIPLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffj_t_RequestClientIPLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RequestClientIPLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RequestSupoortGameListLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RequestSupoortGameListLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffj_t_RequestSupoortGameListLoginUserPmd_Cbase = iota
	ffj_t_RequestSupoortGameListLoginUserPmd_Cno_such_key
)

func (uj *RequestSupoortGameListLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RequestSupoortGameListLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RequestSupoortGameListLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RequestSupoortGameListLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffj_t_RequestSupoortGameListLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RequestSupoortGameListLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RequestUserZoneInfoLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RequestUserZoneInfoLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RequestUserZoneInfoLoginUserPmd_Cbase = iota
	ffj_t_RequestUserZoneInfoLoginUserPmd_Cno_such_key

	ffj_t_RequestUserZoneInfoLoginUserPmd_C_Gameid
)

var ffj_key_RequestUserZoneInfoLoginUserPmd_C_Gameid = []byte("gameid")

func (uj *RequestUserZoneInfoLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RequestUserZoneInfoLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RequestUserZoneInfoLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_RequestUserZoneInfoLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_RequestUserZoneInfoLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RequestUserZoneInfoLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_RequestUserZoneInfoLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RequestUserZoneInfoLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RequestUserZoneInfoLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Userzoneinfo) != 0 {
		buf.WriteString(`"userzoneinfo":`)
		if mj.Userzoneinfo != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Userzoneinfo {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RequestUserZoneInfoLoginUserPmd_Sbase = iota
	ffj_t_RequestUserZoneInfoLoginUserPmd_Sno_such_key

	ffj_t_RequestUserZoneInfoLoginUserPmd_S_Userzoneinfo
)

var ffj_key_RequestUserZoneInfoLoginUserPmd_S_Userzoneinfo = []byte("userzoneinfo")

func (uj *RequestUserZoneInfoLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RequestUserZoneInfoLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RequestUserZoneInfoLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'u':

					if bytes.Equal(ffj_key_RequestUserZoneInfoLoginUserPmd_S_Userzoneinfo, kn) {
						currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_S_Userzoneinfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_RequestUserZoneInfoLoginUserPmd_S_Userzoneinfo, kn) {
					currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_S_Userzoneinfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RequestUserZoneInfoLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RequestUserZoneInfoLoginUserPmd_S_Userzoneinfo:
					goto handle_Userzoneinfo

				case ffj_t_RequestUserZoneInfoLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Userzoneinfo:

	/* handler: uj.Userzoneinfo type=[]*Pmd.UserZoneInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Userzoneinfo = nil
		} else {

			uj.Userzoneinfo = []*UserZoneInfo{}

			wantVal := true

			for {

				var tmp_uj__Userzoneinfo *UserZoneInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Userzoneinfo type=*Pmd.UserZoneInfo kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmp_uj__Userzoneinfo = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if tmp_uj__Userzoneinfo == nil {
						tmp_uj__Userzoneinfo = new(UserZoneInfo)
					}

					err = tmp_uj__Userzoneinfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Userzoneinfo = append(uj.Userzoneinfo, tmp_uj__Userzoneinfo)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *RequestZoneInfoListLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *RequestZoneInfoListLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_RequestZoneInfoListLoginUserPmd_Cbase = iota
	ffj_t_RequestZoneInfoListLoginUserPmd_Cno_such_key

	ffj_t_RequestZoneInfoListLoginUserPmd_C_Gameid
)

var ffj_key_RequestZoneInfoListLoginUserPmd_C_Gameid = []byte("gameid")

func (uj *RequestZoneInfoListLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *RequestZoneInfoListLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_RequestZoneInfoListLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_RequestZoneInfoListLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_RequestZoneInfoListLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_RequestZoneInfoListLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_RequestZoneInfoListLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_RequestZoneInfoListLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_RequestZoneInfoListLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_RequestZoneInfoListLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_RequestZoneInfoListLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReturnAccountRegisterLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReturnAccountRegisterLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Account != nil {
		if true {
			buf.WriteString(`"account":`)
			fflib.WriteJsonString(buf, string(*mj.Account))
			buf.WriteByte(',')
		}
	}
	if mj.Accountid != nil {
		if true {
			buf.WriteString(`"accountid":`)
			fflib.FormatBits2(buf, uint64(*mj.Accountid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReturnAccountRegisterLoginUserPmd_Sbase = iota
	ffj_t_ReturnAccountRegisterLoginUserPmd_Sno_such_key

	ffj_t_ReturnAccountRegisterLoginUserPmd_S_Account

	ffj_t_ReturnAccountRegisterLoginUserPmd_S_Accountid
)

var ffj_key_ReturnAccountRegisterLoginUserPmd_S_Account = []byte("account")

var ffj_key_ReturnAccountRegisterLoginUserPmd_S_Accountid = []byte("accountid")

func (uj *ReturnAccountRegisterLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReturnAccountRegisterLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReturnAccountRegisterLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReturnAccountRegisterLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ReturnAccountRegisterLoginUserPmd_S_Account, kn) {
						currentKey = ffj_t_ReturnAccountRegisterLoginUserPmd_S_Account
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ReturnAccountRegisterLoginUserPmd_S_Accountid, kn) {
						currentKey = ffj_t_ReturnAccountRegisterLoginUserPmd_S_Accountid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ReturnAccountRegisterLoginUserPmd_S_Accountid, kn) {
					currentKey = ffj_t_ReturnAccountRegisterLoginUserPmd_S_Accountid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ReturnAccountRegisterLoginUserPmd_S_Account, kn) {
					currentKey = ffj_t_ReturnAccountRegisterLoginUserPmd_S_Account
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReturnAccountRegisterLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReturnAccountRegisterLoginUserPmd_S_Account:
					goto handle_Account

				case ffj_t_ReturnAccountRegisterLoginUserPmd_S_Accountid:
					goto handle_Accountid

				case ffj_t_ReturnAccountRegisterLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Account:

	/* handler: uj.Account type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Account = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Account = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Accountid:

	/* handler: uj.Accountid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Accountid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Accountid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReturnClientIPLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReturnClientIPLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Pstrip != nil {
		if true {
			buf.WriteString(`"pstrip":`)
			fflib.WriteJsonString(buf, string(*mj.Pstrip))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReturnClientIPLoginUserPmd_Sbase = iota
	ffj_t_ReturnClientIPLoginUserPmd_Sno_such_key

	ffj_t_ReturnClientIPLoginUserPmd_S_Pstrip
)

var ffj_key_ReturnClientIPLoginUserPmd_S_Pstrip = []byte("pstrip")

func (uj *ReturnClientIPLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReturnClientIPLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReturnClientIPLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReturnClientIPLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_ReturnClientIPLoginUserPmd_S_Pstrip, kn) {
						currentKey = ffj_t_ReturnClientIPLoginUserPmd_S_Pstrip
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReturnClientIPLoginUserPmd_S_Pstrip, kn) {
					currentKey = ffj_t_ReturnClientIPLoginUserPmd_S_Pstrip
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReturnClientIPLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReturnClientIPLoginUserPmd_S_Pstrip:
					goto handle_Pstrip

				case ffj_t_ReturnClientIPLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Pstrip:

	/* handler: uj.Pstrip type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Pstrip = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Pstrip = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReturnSupoortGameListLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReturnSupoortGameListLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(mj.Gamelist) != 0 {
		buf.WriteString(`"gamelist":`)
		if mj.Gamelist != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Gamelist {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReturnSupoortGameListLoginUserPmd_Sbase = iota
	ffj_t_ReturnSupoortGameListLoginUserPmd_Sno_such_key

	ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gamelist
)

var ffj_key_ReturnSupoortGameListLoginUserPmd_S_Gamelist = []byte("gamelist")

func (uj *ReturnSupoortGameListLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReturnSupoortGameListLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReturnSupoortGameListLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_ReturnSupoortGameListLoginUserPmd_S_Gamelist, kn) {
						currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gamelist
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReturnSupoortGameListLoginUserPmd_S_Gamelist, kn) {
					currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gamelist
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gamelist:
					goto handle_Gamelist

				case ffj_t_ReturnSupoortGameListLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gamelist:

	/* handler: uj.Gamelist type=[]*Pmd.ReturnSupoortGameListLoginUserPmd_S_Game kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Gamelist = nil
		} else {

			uj.Gamelist = []*ReturnSupoortGameListLoginUserPmd_S_Game{}

			wantVal := true

			for {

				var tmp_uj__Gamelist *ReturnSupoortGameListLoginUserPmd_S_Game

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Gamelist type=*Pmd.ReturnSupoortGameListLoginUserPmd_S_Game kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmp_uj__Gamelist = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if tmp_uj__Gamelist == nil {
						tmp_uj__Gamelist = new(ReturnSupoortGameListLoginUserPmd_S_Game)
					}

					err = tmp_uj__Gamelist.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Gamelist = append(uj.Gamelist, tmp_uj__Gamelist)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ReturnSupoortGameListLoginUserPmd_S_Game) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReturnSupoortGameListLoginUserPmd_S_Game) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Gamename != nil {
		if true {
			buf.WriteString(`"gamename":`)
			fflib.WriteJsonString(buf, string(*mj.Gamename))
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gamebase = iota
	ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gameno_such_key

	ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gamename

	ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gameid
)

var ffj_key_ReturnSupoortGameListLoginUserPmd_S_Game_Gamename = []byte("gamename")

var ffj_key_ReturnSupoortGameListLoginUserPmd_S_Game_Gameid = []byte("gameid")

func (uj *ReturnSupoortGameListLoginUserPmd_S_Game) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReturnSupoortGameListLoginUserPmd_S_Game) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gameno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_ReturnSupoortGameListLoginUserPmd_S_Game_Gamename, kn) {
						currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gamename
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ReturnSupoortGameListLoginUserPmd_S_Game_Gameid, kn) {
						currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ReturnSupoortGameListLoginUserPmd_S_Game_Gameid, kn) {
					currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ReturnSupoortGameListLoginUserPmd_S_Game_Gamename, kn) {
					currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gamename
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gameno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gamename:
					goto handle_Gamename

				case ffj_t_ReturnSupoortGameListLoginUserPmd_S_Game_Gameid:
					goto handle_Gameid

				case ffj_t_ReturnSupoortGameListLoginUserPmd_S_Gameno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gamename:

	/* handler: uj.Gamename type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Gamename = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Gamename = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ServerKickoutLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ServerKickoutLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Accountid != nil {
		if true {
			buf.WriteString(`"accountid":`)
			fflib.FormatBits2(buf, uint64(*mj.Accountid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ServerKickoutLoginUserPmd_Sbase = iota
	ffj_t_ServerKickoutLoginUserPmd_Sno_such_key

	ffj_t_ServerKickoutLoginUserPmd_S_Accountid

	ffj_t_ServerKickoutLoginUserPmd_S_Desc
)

var ffj_key_ServerKickoutLoginUserPmd_S_Accountid = []byte("accountid")

var ffj_key_ServerKickoutLoginUserPmd_S_Desc = []byte("desc")

func (uj *ServerKickoutLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ServerKickoutLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ServerKickoutLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ServerKickoutLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_ServerKickoutLoginUserPmd_S_Accountid, kn) {
						currentKey = ffj_t_ServerKickoutLoginUserPmd_S_Accountid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ServerKickoutLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_ServerKickoutLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ServerKickoutLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_ServerKickoutLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ServerKickoutLoginUserPmd_S_Accountid, kn) {
					currentKey = ffj_t_ServerKickoutLoginUserPmd_S_Accountid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ServerKickoutLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ServerKickoutLoginUserPmd_S_Accountid:
					goto handle_Accountid

				case ffj_t_ServerKickoutLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_ServerKickoutLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Accountid:

	/* handler: uj.Accountid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Accountid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Accountid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *SetServerLangLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *SetServerLangLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Lang != nil {
		if true {
			buf.WriteString(`"lang":`)
			fflib.WriteJsonString(buf, string(*mj.Lang))
			buf.WriteByte(',')
		}
	}
	if mj.Gameregion != nil {
		if true {
			buf.WriteString(`"gameregion":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameregion), 10, *mj.Gameregion < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_SetServerLangLoginUserPmd_Cbase = iota
	ffj_t_SetServerLangLoginUserPmd_Cno_such_key

	ffj_t_SetServerLangLoginUserPmd_C_Lang

	ffj_t_SetServerLangLoginUserPmd_C_Gameregion
)

var ffj_key_SetServerLangLoginUserPmd_C_Lang = []byte("lang")

var ffj_key_SetServerLangLoginUserPmd_C_Gameregion = []byte("gameregion")

func (uj *SetServerLangLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *SetServerLangLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_SetServerLangLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_SetServerLangLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_SetServerLangLoginUserPmd_C_Gameregion, kn) {
						currentKey = ffj_t_SetServerLangLoginUserPmd_C_Gameregion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_SetServerLangLoginUserPmd_C_Lang, kn) {
						currentKey = ffj_t_SetServerLangLoginUserPmd_C_Lang
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_SetServerLangLoginUserPmd_C_Gameregion, kn) {
					currentKey = ffj_t_SetServerLangLoginUserPmd_C_Gameregion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_SetServerLangLoginUserPmd_C_Lang, kn) {
					currentKey = ffj_t_SetServerLangLoginUserPmd_C_Lang
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_SetServerLangLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_SetServerLangLoginUserPmd_C_Lang:
					goto handle_Lang

				case ffj_t_SetServerLangLoginUserPmd_C_Gameregion:
					goto handle_Gameregion

				case ffj_t_SetServerLangLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Lang:

	/* handler: uj.Lang type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Lang = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Lang = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameregion:

	/* handler: uj.Gameregion type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameregion = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.Gameregion = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ThirdPlatLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ThirdPlatLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Platinfo != nil {
		if true {
			buf.WriteString(`"platinfo":`)

			{

				err = mj.Platinfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Sid != nil {
		if true {
			buf.WriteString(`"sid":`)
			fflib.WriteJsonString(buf, string(*mj.Sid))
			buf.WriteByte(',')
		}
	}
	if mj.Uid != nil {
		if true {
			buf.WriteString(`"uid":`)
			fflib.WriteJsonString(buf, string(*mj.Uid))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ThirdPlatLoginUserPmd_Cbase = iota
	ffj_t_ThirdPlatLoginUserPmd_Cno_such_key

	ffj_t_ThirdPlatLoginUserPmd_C_Platinfo

	ffj_t_ThirdPlatLoginUserPmd_C_Gameid

	ffj_t_ThirdPlatLoginUserPmd_C_Sid

	ffj_t_ThirdPlatLoginUserPmd_C_Uid
)

var ffj_key_ThirdPlatLoginUserPmd_C_Platinfo = []byte("platinfo")

var ffj_key_ThirdPlatLoginUserPmd_C_Gameid = []byte("gameid")

var ffj_key_ThirdPlatLoginUserPmd_C_Sid = []byte("sid")

var ffj_key_ThirdPlatLoginUserPmd_C_Uid = []byte("uid")

func (uj *ThirdPlatLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ThirdPlatLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ThirdPlatLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ThirdPlatLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_ThirdPlatLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_ThirdPlatLoginUserPmd_C_Platinfo, kn) {
						currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Platinfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ThirdPlatLoginUserPmd_C_Sid, kn) {
						currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Sid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_ThirdPlatLoginUserPmd_C_Uid, kn) {
						currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Uid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ThirdPlatLoginUserPmd_C_Uid, kn) {
					currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Uid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ThirdPlatLoginUserPmd_C_Sid, kn) {
					currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Sid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ThirdPlatLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ThirdPlatLoginUserPmd_C_Platinfo, kn) {
					currentKey = ffj_t_ThirdPlatLoginUserPmd_C_Platinfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ThirdPlatLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ThirdPlatLoginUserPmd_C_Platinfo:
					goto handle_Platinfo

				case ffj_t_ThirdPlatLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_ThirdPlatLoginUserPmd_C_Sid:
					goto handle_Sid

				case ffj_t_ThirdPlatLoginUserPmd_C_Uid:
					goto handle_Uid

				case ffj_t_ThirdPlatLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Platinfo:

	/* handler: uj.Platinfo type=Pmd.PlatInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Platinfo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Platinfo == nil {
			uj.Platinfo = new(PlatInfo)
		}

		err = uj.Platinfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sid:

	/* handler: uj.Sid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Sid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Sid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Uid:

	/* handler: uj.Uid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Uid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Uid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserLoginReconnectLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserLoginReconnectLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Accountid != nil {
		if true {
			buf.WriteString(`"accountid":`)
			fflib.FormatBits2(buf, uint64(*mj.Accountid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Timestamp != nil {
		if true {
			buf.WriteString(`"timestamp":`)
			fflib.FormatBits2(buf, uint64(*mj.Timestamp), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Tokenmd5 != nil {
		if true {
			buf.WriteString(`"tokenmd5":`)
			fflib.WriteJsonString(buf, string(*mj.Tokenmd5))
			buf.WriteByte(',')
		}
	}
	if mj.Logintempid != nil {
		if true {
			buf.WriteString(`"logintempid":`)
			fflib.FormatBits2(buf, uint64(*mj.Logintempid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Compress != nil {
		if true {
			buf.WriteString(`"compress":`)
			fflib.WriteJsonString(buf, string(*mj.Compress))
			buf.WriteByte(',')
		}
	}
	if mj.Encrypt != nil {
		if true {
			buf.WriteString(`"encrypt":`)
			fflib.WriteJsonString(buf, string(*mj.Encrypt))
			buf.WriteByte(',')
		}
	}
	if mj.Encryptkey != nil {
		if true {
			buf.WriteString(`"encryptkey":`)
			fflib.WriteJsonString(buf, string(*mj.Encryptkey))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.FormatBits2(buf, uint64(*mj.Version), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Compressmin != nil {
		if true {
			buf.WriteString(`"compressmin":`)
			fflib.FormatBits2(buf, uint64(*mj.Compressmin), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Lastseq != nil {
		if true {
			buf.WriteString(`"lastseq":`)
			fflib.FormatBits2(buf, uint64(*mj.Lastseq), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserLoginReconnectLoginUserPmd_Cbase = iota
	ffj_t_UserLoginReconnectLoginUserPmd_Cno_such_key

	ffj_t_UserLoginReconnectLoginUserPmd_C_Accountid

	ffj_t_UserLoginReconnectLoginUserPmd_C_Timestamp

	ffj_t_UserLoginReconnectLoginUserPmd_C_Tokenmd5

	ffj_t_UserLoginReconnectLoginUserPmd_C_Logintempid

	ffj_t_UserLoginReconnectLoginUserPmd_C_Gameid

	ffj_t_UserLoginReconnectLoginUserPmd_C_Zoneid

	ffj_t_UserLoginReconnectLoginUserPmd_C_Compress

	ffj_t_UserLoginReconnectLoginUserPmd_C_Encrypt

	ffj_t_UserLoginReconnectLoginUserPmd_C_Encryptkey

	ffj_t_UserLoginReconnectLoginUserPmd_C_Version

	ffj_t_UserLoginReconnectLoginUserPmd_C_Compressmin

	ffj_t_UserLoginReconnectLoginUserPmd_C_Lastseq
)

var ffj_key_UserLoginReconnectLoginUserPmd_C_Accountid = []byte("accountid")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Timestamp = []byte("timestamp")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Tokenmd5 = []byte("tokenmd5")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Logintempid = []byte("logintempid")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Gameid = []byte("gameid")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Zoneid = []byte("zoneid")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Compress = []byte("compress")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Encrypt = []byte("encrypt")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Encryptkey = []byte("encryptkey")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Version = []byte("version")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Compressmin = []byte("compressmin")

var ffj_key_UserLoginReconnectLoginUserPmd_C_Lastseq = []byte("lastseq")

func (uj *UserLoginReconnectLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserLoginReconnectLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserLoginReconnectLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserLoginReconnectLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Accountid, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Accountid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Compress, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Compress
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Compressmin, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Compressmin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Encrypt, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Encrypt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Encryptkey, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Encryptkey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Logintempid, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Logintempid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Lastseq, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Lastseq
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Timestamp, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Tokenmd5, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Tokenmd5
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Version, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_UserLoginReconnectLoginUserPmd_C_Zoneid, kn) {
						currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReconnectLoginUserPmd_C_Lastseq, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Lastseq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReconnectLoginUserPmd_C_Compressmin, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Compressmin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReconnectLoginUserPmd_C_Version, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReconnectLoginUserPmd_C_Encryptkey, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Encryptkey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReconnectLoginUserPmd_C_Encrypt, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Encrypt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReconnectLoginUserPmd_C_Compress, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Compress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReconnectLoginUserPmd_C_Zoneid, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReconnectLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReconnectLoginUserPmd_C_Logintempid, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Logintempid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReconnectLoginUserPmd_C_Tokenmd5, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Tokenmd5
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReconnectLoginUserPmd_C_Timestamp, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReconnectLoginUserPmd_C_Accountid, kn) {
					currentKey = ffj_t_UserLoginReconnectLoginUserPmd_C_Accountid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserLoginReconnectLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Accountid:
					goto handle_Accountid

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Timestamp:
					goto handle_Timestamp

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Tokenmd5:
					goto handle_Tokenmd5

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Logintempid:
					goto handle_Logintempid

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Zoneid:
					goto handle_Zoneid

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Compress:
					goto handle_Compress

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Encrypt:
					goto handle_Encrypt

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Encryptkey:
					goto handle_Encryptkey

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Version:
					goto handle_Version

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Compressmin:
					goto handle_Compressmin

				case ffj_t_UserLoginReconnectLoginUserPmd_C_Lastseq:
					goto handle_Lastseq

				case ffj_t_UserLoginReconnectLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Accountid:

	/* handler: uj.Accountid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Accountid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Accountid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: uj.Timestamp type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Timestamp = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Timestamp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tokenmd5:

	/* handler: uj.Tokenmd5 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Tokenmd5 = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Tokenmd5 = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Logintempid:

	/* handler: uj.Logintempid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Logintempid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Logintempid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Compress:

	/* handler: uj.Compress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Compress = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Compress = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encrypt:

	/* handler: uj.Encrypt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encrypt = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encrypt = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encryptkey:

	/* handler: uj.Encryptkey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encryptkey = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encryptkey = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Version = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Compressmin:

	/* handler: uj.Compressmin type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Compressmin = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Compressmin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lastseq:

	/* handler: uj.Lastseq type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Lastseq = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Lastseq = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserLoginReconnectOkLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserLoginReconnectOkLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Accid != nil {
		if true {
			buf.WriteString(`"accid":`)
			fflib.FormatBits2(buf, uint64(*mj.Accid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserLoginReconnectOkLoginUserPmd_Sbase = iota
	ffj_t_UserLoginReconnectOkLoginUserPmd_Sno_such_key

	ffj_t_UserLoginReconnectOkLoginUserPmd_S_Accid
)

var ffj_key_UserLoginReconnectOkLoginUserPmd_S_Accid = []byte("accid")

func (uj *UserLoginReconnectOkLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserLoginReconnectOkLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserLoginReconnectOkLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserLoginReconnectOkLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_UserLoginReconnectOkLoginUserPmd_S_Accid, kn) {
						currentKey = ffj_t_UserLoginReconnectOkLoginUserPmd_S_Accid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReconnectOkLoginUserPmd_S_Accid, kn) {
					currentKey = ffj_t_UserLoginReconnectOkLoginUserPmd_S_Accid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserLoginReconnectOkLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserLoginReconnectOkLoginUserPmd_S_Accid:
					goto handle_Accid

				case ffj_t_UserLoginReconnectOkLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Accid:

	/* handler: uj.Accid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Accid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Accid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserLoginRequestLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserLoginRequestLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gameversion != nil {
		if true {
			buf.WriteString(`"gameversion":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameversion), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Mid != nil {
		if true {
			buf.WriteString(`"mid":`)
			fflib.WriteJsonString(buf, string(*mj.Mid))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserLoginRequestLoginUserPmd_Cbase = iota
	ffj_t_UserLoginRequestLoginUserPmd_Cno_such_key

	ffj_t_UserLoginRequestLoginUserPmd_C_Gameid

	ffj_t_UserLoginRequestLoginUserPmd_C_Zoneid

	ffj_t_UserLoginRequestLoginUserPmd_C_Gameversion

	ffj_t_UserLoginRequestLoginUserPmd_C_Mid
)

var ffj_key_UserLoginRequestLoginUserPmd_C_Gameid = []byte("gameid")

var ffj_key_UserLoginRequestLoginUserPmd_C_Zoneid = []byte("zoneid")

var ffj_key_UserLoginRequestLoginUserPmd_C_Gameversion = []byte("gameversion")

var ffj_key_UserLoginRequestLoginUserPmd_C_Mid = []byte("mid")

func (uj *UserLoginRequestLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserLoginRequestLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserLoginRequestLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserLoginRequestLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_UserLoginRequestLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginRequestLoginUserPmd_C_Gameversion, kn) {
						currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Gameversion
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_UserLoginRequestLoginUserPmd_C_Mid, kn) {
						currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Mid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_UserLoginRequestLoginUserPmd_C_Zoneid, kn) {
						currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginRequestLoginUserPmd_C_Mid, kn) {
					currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Mid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginRequestLoginUserPmd_C_Gameversion, kn) {
					currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Gameversion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginRequestLoginUserPmd_C_Zoneid, kn) {
					currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginRequestLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_UserLoginRequestLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserLoginRequestLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserLoginRequestLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_UserLoginRequestLoginUserPmd_C_Zoneid:
					goto handle_Zoneid

				case ffj_t_UserLoginRequestLoginUserPmd_C_Gameversion:
					goto handle_Gameversion

				case ffj_t_UserLoginRequestLoginUserPmd_C_Mid:
					goto handle_Mid

				case ffj_t_UserLoginRequestLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameversion:

	/* handler: uj.Gameversion type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameversion = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameversion = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mid:

	/* handler: uj.Mid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Mid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Mid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserLoginReturnFailLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserLoginReturnFailLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Retcode != nil {
		if true {
			buf.WriteString(`"retcode":`)
			fflib.FormatBits2(buf, uint64(*mj.Retcode), 10, *mj.Retcode < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserLoginReturnFailLoginUserPmd_Sbase = iota
	ffj_t_UserLoginReturnFailLoginUserPmd_Sno_such_key

	ffj_t_UserLoginReturnFailLoginUserPmd_S_Retcode

	ffj_t_UserLoginReturnFailLoginUserPmd_S_Desc
)

var ffj_key_UserLoginReturnFailLoginUserPmd_S_Retcode = []byte("retcode")

var ffj_key_UserLoginReturnFailLoginUserPmd_S_Desc = []byte("desc")

func (uj *UserLoginReturnFailLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserLoginReturnFailLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserLoginReturnFailLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserLoginReturnFailLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_UserLoginReturnFailLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_UserLoginReturnFailLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_UserLoginReturnFailLoginUserPmd_S_Retcode, kn) {
						currentKey = ffj_t_UserLoginReturnFailLoginUserPmd_S_Retcode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReturnFailLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_UserLoginReturnFailLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnFailLoginUserPmd_S_Retcode, kn) {
					currentKey = ffj_t_UserLoginReturnFailLoginUserPmd_S_Retcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserLoginReturnFailLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserLoginReturnFailLoginUserPmd_S_Retcode:
					goto handle_Retcode

				case ffj_t_UserLoginReturnFailLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_UserLoginReturnFailLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Retcode:

	/* handler: uj.Retcode type=Pmd.LoginReturnFailReason kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Retcode = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Retcode == nil {
			uj.Retcode = new(LoginReturnFailReason)
		}

		err = uj.Retcode.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserLoginReturnOkLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserLoginReturnOkLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Accountid != nil {
		if true {
			buf.WriteString(`"accountid":`)
			fflib.FormatBits2(buf, uint64(*mj.Accountid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Logintempid != nil {
		if true {
			buf.WriteString(`"logintempid":`)
			fflib.FormatBits2(buf, uint64(*mj.Logintempid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Tokenid != nil {
		if true {
			buf.WriteString(`"tokenid":`)
			fflib.FormatBits2(buf, uint64(*mj.Tokenid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gatewayurl != nil {
		if true {
			buf.WriteString(`"gatewayurl":`)
			fflib.WriteJsonString(buf, string(*mj.Gatewayurl))
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Separatezoneuid != nil {
		if true {
			if *mj.Separatezoneuid {
				buf.WriteString(`"separatezoneuid":true`)
			} else {
				buf.WriteString(`"separatezoneuid":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Zoneuid != nil {
		if true {
			buf.WriteString(`"zoneuid":`)
			fflib.WriteJsonString(buf, string(*mj.Zoneuid))
			buf.WriteByte(',')
		}
	}
	if mj.Gatewayurltcp != nil {
		if true {
			buf.WriteString(`"gatewayurltcp":`)
			fflib.WriteJsonString(buf, string(*mj.Gatewayurltcp))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserLoginReturnOkLoginUserPmd_Sbase = iota
	ffj_t_UserLoginReturnOkLoginUserPmd_Sno_such_key

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Accountid

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Logintempid

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Tokenid

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurl

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Gameid

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneid

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Separatezoneuid

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneuid

	ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurltcp
)

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Accountid = []byte("accountid")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Logintempid = []byte("logintempid")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Tokenid = []byte("tokenid")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Gatewayurl = []byte("gatewayurl")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Gameid = []byte("gameid")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Zoneid = []byte("zoneid")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Separatezoneuid = []byte("separatezoneuid")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Zoneuid = []byte("zoneuid")

var ffj_key_UserLoginReturnOkLoginUserPmd_S_Gatewayurltcp = []byte("gatewayurltcp")

func (uj *UserLoginReturnOkLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserLoginReturnOkLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserLoginReturnOkLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Accountid, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Accountid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Gatewayurl, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurl
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Gameid, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Gatewayurltcp, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurltcp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Logintempid, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Logintempid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Separatezoneuid, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Separatezoneuid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Tokenid, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Tokenid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Zoneid, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginReturnOkLoginUserPmd_S_Zoneuid, kn) {
						currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneuid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnOkLoginUserPmd_S_Gatewayurltcp, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurltcp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnOkLoginUserPmd_S_Zoneuid, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReturnOkLoginUserPmd_S_Separatezoneuid, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Separatezoneuid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnOkLoginUserPmd_S_Zoneid, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnOkLoginUserPmd_S_Gameid, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnOkLoginUserPmd_S_Gatewayurl, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginReturnOkLoginUserPmd_S_Tokenid, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Tokenid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnOkLoginUserPmd_S_Logintempid, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Logintempid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginReturnOkLoginUserPmd_S_Accountid, kn) {
					currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_S_Accountid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserLoginReturnOkLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Accountid:
					goto handle_Accountid

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Logintempid:
					goto handle_Logintempid

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Tokenid:
					goto handle_Tokenid

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurl:
					goto handle_Gatewayurl

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Gameid:
					goto handle_Gameid

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneid:
					goto handle_Zoneid

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Separatezoneuid:
					goto handle_Separatezoneuid

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Zoneuid:
					goto handle_Zoneuid

				case ffj_t_UserLoginReturnOkLoginUserPmd_S_Gatewayurltcp:
					goto handle_Gatewayurltcp

				case ffj_t_UserLoginReturnOkLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Accountid:

	/* handler: uj.Accountid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Accountid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Accountid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Logintempid:

	/* handler: uj.Logintempid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Logintempid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Logintempid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tokenid:

	/* handler: uj.Tokenid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Tokenid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Tokenid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gatewayurl:

	/* handler: uj.Gatewayurl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Gatewayurl = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Gatewayurl = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Separatezoneuid:

	/* handler: uj.Separatezoneuid type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.Separatezoneuid = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.Separatezoneuid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneuid:

	/* handler: uj.Zoneuid type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Zoneuid = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Zoneuid = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gatewayurltcp:

	/* handler: uj.Gatewayurltcp type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Gatewayurltcp = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Gatewayurltcp = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserLoginTokenLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserLoginTokenLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Accountid != nil {
		if true {
			buf.WriteString(`"accountid":`)
			fflib.FormatBits2(buf, uint64(*mj.Accountid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Logintempid != nil {
		if true {
			buf.WriteString(`"logintempid":`)
			fflib.FormatBits2(buf, uint64(*mj.Logintempid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Timestamp != nil {
		if true {
			buf.WriteString(`"timestamp":`)
			fflib.FormatBits2(buf, uint64(*mj.Timestamp), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Tokenmd5 != nil {
		if true {
			buf.WriteString(`"tokenmd5":`)
			fflib.WriteJsonString(buf, string(*mj.Tokenmd5))
			buf.WriteByte(',')
		}
	}
	if mj.Compress != nil {
		if true {
			buf.WriteString(`"compress":`)
			fflib.WriteJsonString(buf, string(*mj.Compress))
			buf.WriteByte(',')
		}
	}
	if mj.Encrypt != nil {
		if true {
			buf.WriteString(`"encrypt":`)
			fflib.WriteJsonString(buf, string(*mj.Encrypt))
			buf.WriteByte(',')
		}
	}
	if mj.Encryptkey != nil {
		if true {
			buf.WriteString(`"encryptkey":`)
			fflib.WriteJsonString(buf, string(*mj.Encryptkey))
			buf.WriteByte(',')
		}
	}
	if mj.Version != nil {
		if true {
			buf.WriteString(`"version":`)
			fflib.FormatBits2(buf, uint64(*mj.Version), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Compressmin != nil {
		if true {
			buf.WriteString(`"compressmin":`)
			fflib.FormatBits2(buf, uint64(*mj.Compressmin), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Lastseq != nil {
		if true {
			buf.WriteString(`"lastseq":`)
			fflib.FormatBits2(buf, uint64(*mj.Lastseq), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserLoginTokenLoginUserPmd_Cbase = iota
	ffj_t_UserLoginTokenLoginUserPmd_Cno_such_key

	ffj_t_UserLoginTokenLoginUserPmd_C_Gameid

	ffj_t_UserLoginTokenLoginUserPmd_C_Zoneid

	ffj_t_UserLoginTokenLoginUserPmd_C_Accountid

	ffj_t_UserLoginTokenLoginUserPmd_C_Logintempid

	ffj_t_UserLoginTokenLoginUserPmd_C_Timestamp

	ffj_t_UserLoginTokenLoginUserPmd_C_Tokenmd5

	ffj_t_UserLoginTokenLoginUserPmd_C_Compress

	ffj_t_UserLoginTokenLoginUserPmd_C_Encrypt

	ffj_t_UserLoginTokenLoginUserPmd_C_Encryptkey

	ffj_t_UserLoginTokenLoginUserPmd_C_Version

	ffj_t_UserLoginTokenLoginUserPmd_C_Compressmin

	ffj_t_UserLoginTokenLoginUserPmd_C_Lastseq
)

var ffj_key_UserLoginTokenLoginUserPmd_C_Gameid = []byte("gameid")

var ffj_key_UserLoginTokenLoginUserPmd_C_Zoneid = []byte("zoneid")

var ffj_key_UserLoginTokenLoginUserPmd_C_Accountid = []byte("accountid")

var ffj_key_UserLoginTokenLoginUserPmd_C_Logintempid = []byte("logintempid")

var ffj_key_UserLoginTokenLoginUserPmd_C_Timestamp = []byte("timestamp")

var ffj_key_UserLoginTokenLoginUserPmd_C_Tokenmd5 = []byte("tokenmd5")

var ffj_key_UserLoginTokenLoginUserPmd_C_Compress = []byte("compress")

var ffj_key_UserLoginTokenLoginUserPmd_C_Encrypt = []byte("encrypt")

var ffj_key_UserLoginTokenLoginUserPmd_C_Encryptkey = []byte("encryptkey")

var ffj_key_UserLoginTokenLoginUserPmd_C_Version = []byte("version")

var ffj_key_UserLoginTokenLoginUserPmd_C_Compressmin = []byte("compressmin")

var ffj_key_UserLoginTokenLoginUserPmd_C_Lastseq = []byte("lastseq")

func (uj *UserLoginTokenLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserLoginTokenLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserLoginTokenLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserLoginTokenLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Accountid, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Accountid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Compress, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Compress
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Compressmin, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Compressmin
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Encrypt, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Encrypt
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Encryptkey, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Encryptkey
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Logintempid, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Logintempid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Lastseq, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Lastseq
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Timestamp, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Timestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Tokenmd5, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Tokenmd5
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Version, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Version
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_UserLoginTokenLoginUserPmd_C_Zoneid, kn) {
						currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserLoginTokenLoginUserPmd_C_Lastseq, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Lastseq
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginTokenLoginUserPmd_C_Compressmin, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Compressmin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginTokenLoginUserPmd_C_Version, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Version
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginTokenLoginUserPmd_C_Encryptkey, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Encryptkey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginTokenLoginUserPmd_C_Encrypt, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Encrypt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginTokenLoginUserPmd_C_Compress, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Compress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginTokenLoginUserPmd_C_Tokenmd5, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Tokenmd5
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserLoginTokenLoginUserPmd_C_Timestamp, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Timestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginTokenLoginUserPmd_C_Logintempid, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Logintempid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginTokenLoginUserPmd_C_Accountid, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Accountid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginTokenLoginUserPmd_C_Zoneid, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserLoginTokenLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_UserLoginTokenLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserLoginTokenLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserLoginTokenLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_UserLoginTokenLoginUserPmd_C_Zoneid:
					goto handle_Zoneid

				case ffj_t_UserLoginTokenLoginUserPmd_C_Accountid:
					goto handle_Accountid

				case ffj_t_UserLoginTokenLoginUserPmd_C_Logintempid:
					goto handle_Logintempid

				case ffj_t_UserLoginTokenLoginUserPmd_C_Timestamp:
					goto handle_Timestamp

				case ffj_t_UserLoginTokenLoginUserPmd_C_Tokenmd5:
					goto handle_Tokenmd5

				case ffj_t_UserLoginTokenLoginUserPmd_C_Compress:
					goto handle_Compress

				case ffj_t_UserLoginTokenLoginUserPmd_C_Encrypt:
					goto handle_Encrypt

				case ffj_t_UserLoginTokenLoginUserPmd_C_Encryptkey:
					goto handle_Encryptkey

				case ffj_t_UserLoginTokenLoginUserPmd_C_Version:
					goto handle_Version

				case ffj_t_UserLoginTokenLoginUserPmd_C_Compressmin:
					goto handle_Compressmin

				case ffj_t_UserLoginTokenLoginUserPmd_C_Lastseq:
					goto handle_Lastseq

				case ffj_t_UserLoginTokenLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Accountid:

	/* handler: uj.Accountid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Accountid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Accountid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Logintempid:

	/* handler: uj.Logintempid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Logintempid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Logintempid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: uj.Timestamp type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Timestamp = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Timestamp = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tokenmd5:

	/* handler: uj.Tokenmd5 type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Tokenmd5 = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Tokenmd5 = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Compress:

	/* handler: uj.Compress type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Compress = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Compress = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encrypt:

	/* handler: uj.Encrypt type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encrypt = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encrypt = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Encryptkey:

	/* handler: uj.Encryptkey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Encryptkey = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Encryptkey = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Version:

	/* handler: uj.Version type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Version = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Version = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Compressmin:

	/* handler: uj.Compressmin type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Compressmin = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Compressmin = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Lastseq:

	/* handler: uj.Lastseq type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Lastseq = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Lastseq = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserLogoutTokenLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserLogoutTokenLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffj_t_UserLogoutTokenLoginUserPmd_Cbase = iota
	ffj_t_UserLogoutTokenLoginUserPmd_Cno_such_key
)

func (uj *UserLogoutTokenLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserLogoutTokenLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserLogoutTokenLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserLogoutTokenLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffj_t_UserLogoutTokenLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserLogoutTokenLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserRequestPlatTokenByPasswordLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserRequestPlatTokenByPasswordLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Platid != nil {
		if true {
			buf.WriteString(`"platid":`)
			fflib.FormatBits2(buf, uint64(*mj.Platid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Account != nil {
		if true {
			buf.WriteString(`"account":`)
			fflib.WriteJsonString(buf, string(*mj.Account))
			buf.WriteByte(',')
		}
	}
	if mj.Password != nil {
		if true {
			buf.WriteString(`"password":`)
			fflib.WriteJsonString(buf, string(*mj.Password))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_Cbase = iota
	ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_Cno_such_key

	ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Gameid

	ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Platid

	ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Account

	ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Password
)

var ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Gameid = []byte("gameid")

var ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Platid = []byte("platid")

var ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Account = []byte("account")

var ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Password = []byte("password")

func (uj *UserRequestPlatTokenByPasswordLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserRequestPlatTokenByPasswordLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Account, kn) {
						currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Account
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Platid, kn) {
						currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Platid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Password, kn) {
						currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Password
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Password, kn) {
					currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Password
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Account, kn) {
					currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Account
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Platid, kn) {
					currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Platid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenByPasswordLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Platid:
					goto handle_Platid

				case ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Account:
					goto handle_Account

				case ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_C_Password:
					goto handle_Password

				case ffj_t_UserRequestPlatTokenByPasswordLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platid:

	/* handler: uj.Platid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Platid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Platid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Account:

	/* handler: uj.Account type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Account = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Account = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Password:

	/* handler: uj.Password type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Password = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Password = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserRequestPlatTokenByThirdLoginUserPmd_C) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserRequestPlatTokenByThirdLoginUserPmd_C) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Platinfo != nil {
		if true {
			buf.WriteString(`"platinfo":`)

			{

				err = mj.Platinfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_Cbase = iota
	ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_Cno_such_key

	ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Platinfo

	ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Gameid
)

var ffj_key_UserRequestPlatTokenByThirdLoginUserPmd_C_Platinfo = []byte("platinfo")

var ffj_key_UserRequestPlatTokenByThirdLoginUserPmd_C_Gameid = []byte("gameid")

func (uj *UserRequestPlatTokenByThirdLoginUserPmd_C) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserRequestPlatTokenByThirdLoginUserPmd_C) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_Cbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_UserRequestPlatTokenByThirdLoginUserPmd_C_Gameid, kn) {
						currentKey = ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_UserRequestPlatTokenByThirdLoginUserPmd_C_Platinfo, kn) {
						currentKey = ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Platinfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenByThirdLoginUserPmd_C_Gameid, kn) {
					currentKey = ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenByThirdLoginUserPmd_C_Platinfo, kn) {
					currentKey = ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Platinfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_Cno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Platinfo:
					goto handle_Platinfo

				case ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_C_Gameid:
					goto handle_Gameid

				case ffj_t_UserRequestPlatTokenByThirdLoginUserPmd_Cno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Platinfo:

	/* handler: uj.Platinfo type=Pmd.PlatInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Platinfo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Platinfo == nil {
			uj.Platinfo = new(PlatInfo)
		}

		err = uj.Platinfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserRequestPlatTokenLoginFailLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserRequestPlatTokenLoginFailLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Retcode != nil {
		if true {
			buf.WriteString(`"retcode":`)
			fflib.FormatBits2(buf, uint64(*mj.Retcode), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Desc != nil {
		if true {
			buf.WriteString(`"desc":`)
			fflib.WriteJsonString(buf, string(*mj.Desc))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_Sbase = iota
	ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_Sno_such_key

	ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Retcode

	ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Desc
)

var ffj_key_UserRequestPlatTokenLoginFailLoginUserPmd_S_Retcode = []byte("retcode")

var ffj_key_UserRequestPlatTokenLoginFailLoginUserPmd_S_Desc = []byte("desc")

func (uj *UserRequestPlatTokenLoginFailLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserRequestPlatTokenLoginFailLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_UserRequestPlatTokenLoginFailLoginUserPmd_S_Desc, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Desc
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_UserRequestPlatTokenLoginFailLoginUserPmd_S_Retcode, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Retcode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserRequestPlatTokenLoginFailLoginUserPmd_S_Desc, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Desc
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenLoginFailLoginUserPmd_S_Retcode, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Retcode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Retcode:
					goto handle_Retcode

				case ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_S_Desc:
					goto handle_Desc

				case ffj_t_UserRequestPlatTokenLoginFailLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Retcode:

	/* handler: uj.Retcode type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Retcode = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Retcode = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Desc:

	/* handler: uj.Desc type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Desc = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Desc = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserRequestPlatTokenLoginOkLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserRequestPlatTokenLoginOkLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Uid != nil {
		if true {
			buf.WriteString(`"uid":`)
			fflib.FormatBits2(buf, uint64(*mj.Uid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Platkey != nil {
		if true {
			buf.WriteString(`"platkey":`)
			fflib.WriteJsonString(buf, string(*mj.Platkey))
			buf.WriteByte(',')
		}
	}
	if mj.Platlogin != nil {
		if true {
			buf.WriteString(`"platlogin":`)
			fflib.WriteJsonString(buf, string(*mj.Platlogin))
			buf.WriteByte(',')
		}
	}
	if mj.Platloginlife != nil {
		if true {
			buf.WriteString(`"platloginlife":`)
			fflib.FormatBits2(buf, uint64(*mj.Platloginlife), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Timezonename != nil {
		if true {
			buf.WriteString(`"timezonename":`)
			fflib.WriteJsonString(buf, string(*mj.Timezonename))
			buf.WriteByte(',')
		}
	}
	if mj.Timezoneoffset != nil {
		if true {
			buf.WriteString(`"timezoneoffset":`)
			fflib.FormatBits2(buf, uint64(*mj.Timezoneoffset), 10, *mj.Timezoneoffset < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Platinfo != nil {
		if true {
			buf.WriteString(`"platinfo":`)

			{

				err = mj.Platinfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_Sbase = iota
	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_Sno_such_key

	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Uid

	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platkey

	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platlogin

	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platloginlife

	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezonename

	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezoneoffset

	ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platinfo
)

var ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Uid = []byte("uid")

var ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platkey = []byte("platkey")

var ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platlogin = []byte("platlogin")

var ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platloginlife = []byte("platloginlife")

var ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezonename = []byte("timezonename")

var ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezoneoffset = []byte("timezoneoffset")

var ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platinfo = []byte("platinfo")

func (uj *UserRequestPlatTokenLoginOkLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserRequestPlatTokenLoginOkLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platkey, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platkey
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platlogin, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platlogin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platloginlife, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platloginlife
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platinfo, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platinfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezonename, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezonename
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezoneoffset, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezoneoffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Uid, kn) {
						currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Uid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platinfo, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platinfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezoneoffset, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezoneoffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezonename, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezonename
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platloginlife, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platloginlife
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platlogin, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platlogin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platkey, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platkey
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserRequestPlatTokenLoginOkLoginUserPmd_S_Uid, kn) {
					currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Uid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Uid:
					goto handle_Uid

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platkey:
					goto handle_Platkey

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platlogin:
					goto handle_Platlogin

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platloginlife:
					goto handle_Platloginlife

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezonename:
					goto handle_Timezonename

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Timezoneoffset:
					goto handle_Timezoneoffset

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_S_Platinfo:
					goto handle_Platinfo

				case ffj_t_UserRequestPlatTokenLoginOkLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Uid:

	/* handler: uj.Uid type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Uid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Uid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platkey:

	/* handler: uj.Platkey type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Platkey = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Platkey = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platlogin:

	/* handler: uj.Platlogin type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Platlogin = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Platlogin = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platloginlife:

	/* handler: uj.Platloginlife type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Platloginlife = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Platloginlife = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timezonename:

	/* handler: uj.Timezonename type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Timezonename = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Timezonename = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timezoneoffset:

	/* handler: uj.Timezoneoffset type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Timezoneoffset = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.Timezoneoffset = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Platinfo:

	/* handler: uj.Platinfo type=Pmd.PlatInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Platinfo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Platinfo == nil {
			uj.Platinfo = new(PlatInfo)
		}

		err = uj.Platinfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *UserZoneInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserZoneInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Charname != nil {
		if true {
			buf.WriteString(`"charname":`)
			fflib.WriteJsonString(buf, string(*mj.Charname))
			buf.WriteByte(',')
		}
	}
	if mj.Zoneinfo != nil {
		if true {
			buf.WriteString(`"zoneinfo":`)

			{

				err = mj.Zoneinfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Onlinenum != nil {
		if true {
			buf.WriteString(`"onlinenum":`)
			fflib.FormatBits2(buf, uint64(*mj.Onlinenum), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserZoneInfobase = iota
	ffj_t_UserZoneInfono_such_key

	ffj_t_UserZoneInfo_Charname

	ffj_t_UserZoneInfo_Zoneinfo

	ffj_t_UserZoneInfo_Onlinenum
)

var ffj_key_UserZoneInfo_Charname = []byte("charname")

var ffj_key_UserZoneInfo_Zoneinfo = []byte("zoneinfo")

var ffj_key_UserZoneInfo_Onlinenum = []byte("onlinenum")

func (uj *UserZoneInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserZoneInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserZoneInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserZoneInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_UserZoneInfo_Charname, kn) {
						currentKey = ffj_t_UserZoneInfo_Charname
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_UserZoneInfo_Onlinenum, kn) {
						currentKey = ffj_t_UserZoneInfo_Onlinenum
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_UserZoneInfo_Zoneinfo, kn) {
						currentKey = ffj_t_UserZoneInfo_Zoneinfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserZoneInfo_Onlinenum, kn) {
					currentKey = ffj_t_UserZoneInfo_Onlinenum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserZoneInfo_Zoneinfo, kn) {
					currentKey = ffj_t_UserZoneInfo_Zoneinfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_UserZoneInfo_Charname, kn) {
					currentKey = ffj_t_UserZoneInfo_Charname
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserZoneInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserZoneInfo_Charname:
					goto handle_Charname

				case ffj_t_UserZoneInfo_Zoneinfo:
					goto handle_Zoneinfo

				case ffj_t_UserZoneInfo_Onlinenum:
					goto handle_Onlinenum

				case ffj_t_UserZoneInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Charname:

	/* handler: uj.Charname type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Charname = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Charname = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneinfo:

	/* handler: uj.Zoneinfo type=Pmd.ZoneInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Zoneinfo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Zoneinfo == nil {
			uj.Zoneinfo = new(ZoneInfo)
		}

		err = uj.Zoneinfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Onlinenum:

	/* handler: uj.Onlinenum type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Onlinenum = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Onlinenum = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ZoneInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ZoneInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Zonename != nil {
		if true {
			buf.WriteString(`"zonename":`)
			fflib.WriteJsonString(buf, string(*mj.Zonename))
			buf.WriteByte(',')
		}
	}
	if mj.State != nil {
		if true {
			buf.WriteString(`"state":`)
			fflib.FormatBits2(buf, uint64(*mj.State), 10, *mj.State < 0)
			buf.WriteByte(',')
		}
	}
	if mj.Opentime != nil {
		if true {
			buf.WriteString(`"opentime":`)
			fflib.WriteJsonString(buf, string(*mj.Opentime))
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Iconurl != nil {
		if true {
			buf.WriteString(`"iconurl":`)
			fflib.WriteJsonString(buf, string(*mj.Iconurl))
			buf.WriteByte(',')
		}
	}
	if mj.Bitmask != nil {
		if true {
			buf.WriteString(`"bitmask":`)
			fflib.FormatBits2(buf, uint64(*mj.Bitmask), 10, false)
			buf.WriteByte(',')
		}
	}
	if mj.Gamename != nil {
		if true {
			buf.WriteString(`"gamename":`)
			fflib.WriteJsonString(buf, string(*mj.Gamename))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ZoneInfobase = iota
	ffj_t_ZoneInfono_such_key

	ffj_t_ZoneInfo_Zoneid

	ffj_t_ZoneInfo_Zonename

	ffj_t_ZoneInfo_State

	ffj_t_ZoneInfo_Opentime

	ffj_t_ZoneInfo_Gameid

	ffj_t_ZoneInfo_Iconurl

	ffj_t_ZoneInfo_Bitmask

	ffj_t_ZoneInfo_Gamename
)

var ffj_key_ZoneInfo_Zoneid = []byte("zoneid")

var ffj_key_ZoneInfo_Zonename = []byte("zonename")

var ffj_key_ZoneInfo_State = []byte("state")

var ffj_key_ZoneInfo_Opentime = []byte("opentime")

var ffj_key_ZoneInfo_Gameid = []byte("gameid")

var ffj_key_ZoneInfo_Iconurl = []byte("iconurl")

var ffj_key_ZoneInfo_Bitmask = []byte("bitmask")

var ffj_key_ZoneInfo_Gamename = []byte("gamename")

func (uj *ZoneInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ZoneInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ZoneInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ZoneInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffj_key_ZoneInfo_Bitmask, kn) {
						currentKey = ffj_t_ZoneInfo_Bitmask
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_ZoneInfo_Gameid, kn) {
						currentKey = ffj_t_ZoneInfo_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ZoneInfo_Gamename, kn) {
						currentKey = ffj_t_ZoneInfo_Gamename
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ZoneInfo_Iconurl, kn) {
						currentKey = ffj_t_ZoneInfo_Iconurl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ZoneInfo_Opentime, kn) {
						currentKey = ffj_t_ZoneInfo_Opentime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ZoneInfo_State, kn) {
						currentKey = ffj_t_ZoneInfo_State
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_ZoneInfo_Zoneid, kn) {
						currentKey = ffj_t_ZoneInfo_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ZoneInfo_Zonename, kn) {
						currentKey = ffj_t_ZoneInfo_Zonename
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfo_Gamename, kn) {
					currentKey = ffj_t_ZoneInfo_Gamename
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ZoneInfo_Bitmask, kn) {
					currentKey = ffj_t_ZoneInfo_Bitmask
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfo_Iconurl, kn) {
					currentKey = ffj_t_ZoneInfo_Iconurl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfo_Gameid, kn) {
					currentKey = ffj_t_ZoneInfo_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfo_Opentime, kn) {
					currentKey = ffj_t_ZoneInfo_Opentime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ZoneInfo_State, kn) {
					currentKey = ffj_t_ZoneInfo_State
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfo_Zonename, kn) {
					currentKey = ffj_t_ZoneInfo_Zonename
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfo_Zoneid, kn) {
					currentKey = ffj_t_ZoneInfo_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ZoneInfono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ZoneInfo_Zoneid:
					goto handle_Zoneid

				case ffj_t_ZoneInfo_Zonename:
					goto handle_Zonename

				case ffj_t_ZoneInfo_State:
					goto handle_State

				case ffj_t_ZoneInfo_Opentime:
					goto handle_Opentime

				case ffj_t_ZoneInfo_Gameid:
					goto handle_Gameid

				case ffj_t_ZoneInfo_Iconurl:
					goto handle_Iconurl

				case ffj_t_ZoneInfo_Bitmask:
					goto handle_Bitmask

				case ffj_t_ZoneInfo_Gamename:
					goto handle_Gamename

				case ffj_t_ZoneInfono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zonename:

	/* handler: uj.Zonename type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Zonename = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Zonename = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: uj.State type=Pmd.ZoneState kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.State = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.State == nil {
			uj.State = new(ZoneState)
		}

		err = uj.State.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Opentime:

	/* handler: uj.Opentime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Opentime = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Opentime = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Iconurl:

	/* handler: uj.Iconurl type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Iconurl = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Iconurl = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Bitmask:

	/* handler: uj.Bitmask type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Bitmask = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Bitmask = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gamename:

	/* handler: uj.Gamename type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Gamename = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Gamename = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *ZoneInfoListLoginUserPmd_S) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ZoneInfoListLoginUserPmd_S) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Gamename != nil {
		if true {
			buf.WriteString(`"gamename":`)
			fflib.WriteJsonString(buf, string(*mj.Gamename))
			buf.WriteByte(',')
		}
	}
	if mj.Gameid != nil {
		if true {
			buf.WriteString(`"gameid":`)
			fflib.FormatBits2(buf, uint64(*mj.Gameid), 10, false)
			buf.WriteByte(',')
		}
	}
	if len(mj.Zonelist) != 0 {
		buf.WriteString(`"zonelist":`)
		if mj.Zonelist != nil {
			buf.WriteString(`[`)
			for i, v := range mj.Zonelist {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.Zoneid != nil {
		if true {
			buf.WriteString(`"zoneid":`)
			fflib.FormatBits2(buf, uint64(*mj.Zoneid), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ZoneInfoListLoginUserPmd_Sbase = iota
	ffj_t_ZoneInfoListLoginUserPmd_Sno_such_key

	ffj_t_ZoneInfoListLoginUserPmd_S_Gamename

	ffj_t_ZoneInfoListLoginUserPmd_S_Gameid

	ffj_t_ZoneInfoListLoginUserPmd_S_Zonelist

	ffj_t_ZoneInfoListLoginUserPmd_S_Zoneid
)

var ffj_key_ZoneInfoListLoginUserPmd_S_Gamename = []byte("gamename")

var ffj_key_ZoneInfoListLoginUserPmd_S_Gameid = []byte("gameid")

var ffj_key_ZoneInfoListLoginUserPmd_S_Zonelist = []byte("zonelist")

var ffj_key_ZoneInfoListLoginUserPmd_S_Zoneid = []byte("zoneid")

func (uj *ZoneInfoListLoginUserPmd_S) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ZoneInfoListLoginUserPmd_S) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ZoneInfoListLoginUserPmd_Sbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ZoneInfoListLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_ZoneInfoListLoginUserPmd_S_Gamename, kn) {
						currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Gamename
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ZoneInfoListLoginUserPmd_S_Gameid, kn) {
						currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Gameid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'z':

					if bytes.Equal(ffj_key_ZoneInfoListLoginUserPmd_S_Zonelist, kn) {
						currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Zonelist
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ZoneInfoListLoginUserPmd_S_Zoneid, kn) {
						currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Zoneid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfoListLoginUserPmd_S_Zoneid, kn) {
					currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Zoneid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ZoneInfoListLoginUserPmd_S_Zonelist, kn) {
					currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Zonelist
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfoListLoginUserPmd_S_Gameid, kn) {
					currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Gameid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ZoneInfoListLoginUserPmd_S_Gamename, kn) {
					currentKey = ffj_t_ZoneInfoListLoginUserPmd_S_Gamename
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ZoneInfoListLoginUserPmd_Sno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ZoneInfoListLoginUserPmd_S_Gamename:
					goto handle_Gamename

				case ffj_t_ZoneInfoListLoginUserPmd_S_Gameid:
					goto handle_Gameid

				case ffj_t_ZoneInfoListLoginUserPmd_S_Zonelist:
					goto handle_Zonelist

				case ffj_t_ZoneInfoListLoginUserPmd_S_Zoneid:
					goto handle_Zoneid

				case ffj_t_ZoneInfoListLoginUserPmd_Sno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Gamename:

	/* handler: uj.Gamename type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Gamename = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Gamename = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Gameid:

	/* handler: uj.Gameid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Gameid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Gameid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zonelist:

	/* handler: uj.Zonelist type=[]*Pmd.ZoneInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Zonelist = nil
		} else {

			uj.Zonelist = []*ZoneInfo{}

			wantVal := true

			for {

				var tmp_uj__Zonelist *ZoneInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Zonelist type=*Pmd.ZoneInfo kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmp_uj__Zonelist = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if tmp_uj__Zonelist == nil {
						tmp_uj__Zonelist = new(ZoneInfo)
					}

					err = tmp_uj__Zonelist.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Zonelist = append(uj.Zonelist, tmp_uj__Zonelist)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Zoneid:

	/* handler: uj.Zoneid type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Zoneid = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint32(tval)
			uj.Zoneid = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
